def generate_prompt_parts(input):
    prompt_parts = [
        "input: Faculty of \\nComputer \\nScience\\nEnterprise\\nResource\\nPlanning \\n(INF 433)\\n2023 / 2024\\nCourse Contents\\nEnterprise Systems (ES)\\nHuman Resources Management \\n(HRM)\\n----------------------------------------------------------------------------------------------\\nCustomer Relationship Management \\n(CRM)\\n----------------------------------------------------------------------------------------------\\nInventory Management (IM) \\n[Inventory Control (IC)]\\n----------------------------------------------------------------------------------------------\\nSupply Chain Management (SCM)\\n----------------------------------------------------------------------------------------------\\nBusiness Intelligent  (BI)\\n----------------------------------------------------------------------------------------------\\nFinancial Management (FM) \\n6 ERP\\nModules \\nHuman Resource Management \\n(HRM) \\nThe objective of an ERP for HR is\\nto\\nautomate\\nadministrative\\ntasks and speed up internal\\nprocesses\\nto\\nsave\\nteam\\nmembers a great deal of time\\nand effort.\\nIt is used as a tool for \\nmanagement, payroll, \\nrecruitment, evaluations and job \\noffers.\\nERP consists of a range \\nof modules that serve \\ndifferent business areas. \\nMost ERP systems include core HR\\nfunctions, such as payroll, benefits, \\npersonnel management, employee self-\\nservice, employee performance metrics, \\nhealth and safety, workforce management, \nand training.\nGenerate 2 easy true/false questions with their answers",
        "output: {\"questions\": [{\"question\": \"The objective of ERP System is to slow down the process\",\"answer\": \"False\"},{\n\"question\": \"ERP systems include core HR, functions, such as payroll, benefits, personnel management.\",\n\"answer\": \"True\"}]}",
        "input: Features \\nof an \\nHRMS\\n• Payroll\\nmanagement:\\nrecord\\nand\\nmonitor payroll adjustments, send\\ninformation to your payroll manager\\nor agency, etc.\\n• Time\\nand\\nattendance\\nmanagement: record the time each\\nemployee’s clocks in and out to\\ncomply\\nwith\\nemployment\\nlaws.\\nStores this data for four years.\\n• Employee\\nportal:\\nEmployees\\ncan\\naccess information that’s relevant to\\nthem (holidays, pay slips, etc.).\\nFeatures \\nof an \\nHRMS\\n• Workflows: task automation to save\\ntime.\\n• Absence\\nand\\nleave:\\nmanagement\\nand\\nauthorization\\nof\\nemployees’\\nleave and\\nabsences\\nvia\\na single\\nchannel.\\n• Performance evaluation: design and\\nimplementation\\nof\\nperformance\\nreviews within the company.\\n• Recruitment and selection: support\\nfor talent selection by filtering CVs,\\nconsolidate communication, design\\nthe interview process, etc.\\nFeatures \\nof an \\nHRMS\\n• Org chart: design the organizational\\nstructure\\nto\\nunderstand\\ninternal\\nflows better.\\n• Workplace\\nsurveys:\\nsend\\nquestionnaires\\nautomatically\\nto\\ngauge employees’ satisfaction levels.\\n• Reporting and analysis: automatic\\nand\\nconfigurable\\nreports\\nwith\\nvaluable information for HR.\\n• Attracting,\\nselecting,\\nand\\nhiring new employees\\n• Communicating\\ninformation\\nregarding new positions and\\nhires\\n• Ensuring\\nproper\\neducation,\\ntraining, and certification for\\nemployees\\n• Handling\\nissues\\nrelated\\nto\\nemployee conduct\\n• Making\\nsure\\nemployees\\nunderstand\\njob\\nresponsibilities\\nHR department responsibilities are:\\n•\\nUsing effective process to\\nreview\\nemployee\\nperformance and determine\\nsalary\\nincreases\\nand\\nbonuses\\n•\\nManaging\\nsalary\\nand\\nbenefits for each employee\\n•\\nCommunicating changes in\\nsalaries, benefits, or policies\\nto employees\\n•\\nSupporting\\nmanagement\\nplans\\nfor\\nchanges\\nin\\nthe\\norganization\\nHR department responsibilities are:\\nERP\\nHRMS\\n• An ERP is designed from a business\\nmanagement perspective\\n• An ERP system is primarily for\\norganizations\\nthat\\nneed\\nto\\nintegrate departments to share\\ndata and workflows.\\n• It helps teams manage the day-to-\\nday\\nactivities\\nthat\\nkeep\\ntheir\\norganization\\nafloat,\\nincluding\\nprocurement,\\naccounting, risk management and\\nsupply chain management.\\n• An HRMS serves the specific needs\\nof a human resources department\nGenerate 1 easy multiple choice question with four answers and one answer only is correct",
        "output: {\n  \"questions\": [\n    {\n      \"question\": \"Which of the following features is specific to an HRMS rather than an ERP system?\",\n      \"options\": [\n        \"A) Managing procurement processes\",\n        \"B) Designing organizational structure through org charts\",\n        \"C) Integrating departments to share data and workflows\",\n        \"D) Automating payroll adjustments and monitoring\"\n      ],\n      \"correct_answer\": \"D) Automating payroll adjustments and monitoring\"\n    }\n  ]\n}",
        "input: WEEK 3 \\nVIEWS AND VIEWPOINTS\\nEXAMPLE VIEW - THE OPEN GROUP BUSINESS \\nDOMAINS IN 2001\\n4\\nVIEWS AND VIEWPOINTS\\n7\\nSoftware Architecture: Foundations, Theory, and Practice; Richard N. Taylor, Nenad Medvidovic, and Eric M. Dashofy; © 2008 John Wiley & Sons, Inc. Reprinted with permission.\\nViews are used to structure the architectural description into a number of pieces,\\neach describing one aspect of the system (the functional structure, the deployment\\nenvironment, the development constraints and so on). The architectural description\\nis made up of a set of views.\\nViewpoints provide templates for the views and as such a particular viewpoint is\\nused to develop each view. A viewpoint provides the architect with guidance by\\ndefining what the corresponding view should or may contain, how to represent it,\\nhow to go about developing it, potential problems to be aware of and their solution,\\nand so on.\\n… VIEWS AND VIEWPOINT\\nThe use of Viewpoints and Views is an existing approach, that we have used\\nsuccessfully, for dealing with complex architectural structures. Both ideas are simple\\nbut have proved to be effective:\\nThe relationship between view and viewpoint is similar to that of object and class. Using\\nviewpoints and views helps to organize both the process being followed (the viewpoints\\nproviding implicit structure and explicit guidance) and the artefacts produced (the views being\\nan organization of the architectural description).\\nARCHITECTURE VIEW MODEL\\n9\\nSoftware Architecture: Foundations, Theory, and Practice; Richard N. Taylor, Nenad Medvidovic, and Eric M. Dashofy; © 2008 John Wiley & Sons, Inc. Reprinted with permission.\\nA model is a complete, basic, and simplified description of software architecture\\nwhich is composed of multiple views from a particular perspective or viewpoint.\\nA view is a representation of an entire system from the perspective of a related set\\nof concerns. It is used to describe the system from the viewpoint of different\\nstakeholders such as end-users, developers, project managers, and testers.\\n4+1 VIEW MODEL\\n10\\nSoftware Architecture: Foundations, Theory, and Practice; Richard N. Taylor, Nenad Medvidovic, and Eric M. Dashofy; © 2008 John Wiley & Sons, Inc. Reprinted with permission.\\n The 4+1 View Model was designed by Philippe Kruchten.\\n It describes the architecture of a software–intensive system based on the use of\\nmultiple and concurrent views. It is a multiple view model that addresses different\\nfeatures and concerns of the system. It standardizes the software design documents\\nand makes the design easy to understand by all stakeholders.\\n It is an architecture verification method for studying and documenting software\\narchitecture design and covers all the aspects of software architecture for all\\nstakeholders. It provides four essential views −\\n… 4+1 VIEW MODEL\\n12\\nSoftware Architecture: Foundations, Theory, and Practice; Richard N. Taylor, Nenad Medvidovic, and Eric M. Dashofy; © 2008 John Wiley & Sons, Inc. Reprinted with permission.\\n The logical view or conceptual view − It describes the object model of the design.\\n The process view − It describes the activities of the system, captures the concurrency and\\nsynchronization aspects of the design.\\n The physical view − It describes the mapping of software onto hardware and reflects its distributed\\naspect.\\n The development view − It describes the static organization or structure of the software in its\\ndevelopment of environment.\\nThis view model can be extended by adding one more view called scenario view or use case view for\\nend-users or customers of software systems. It is coherent with other four views and are utilized to\\nillustrate the architecture serving as “plus one” view, (4+1) view model.\nGenerate 1 hard short answer question with its answer",
        "output: {\n  \"questions\": [\n    {\n      \"question\": \"What are views and viewpoints in the context of software architecture, and how do they contribute to organizing architectural descriptions?\",\n      \"answer\": \"Views in software architecture structure the architectural description into pieces, each focusing on a specific aspect of the system. Viewpoints provide templates for these views, guiding architects on content, representation, and development. Together, they organize the architectural process and its artifacts, offering structure and guidance.\"\n    }\n  ]\n}",
        "input: Local Data Storage\\nFirst you need Installing Packages for Local (on Device) Data Storage to avoid\\nloss of data stored in RAM that may deleted by the operating system. These\\npackages include:\\nPath provider package , patt package, sqflite package\\n$flutter pub add path_provider\\n$flutter pub add path\\n$flutter pub add sqflite\\nConsider our example of Favorite Places APP. Assume we need storing\\nimages in the system directory specified for saving images\\nThis statement retrieve the system directory to store files\\nYou also can store meta data related to each place using sql commands\\nFirst import the required packages\\nThen inside addPlace function ,\\n-\\nGet system database directory\\n-\\nOpen the directory\\n-\\nJoin command will open the database places.db ( extension should be .db)\\n-\\nOncreate command is executed only at the first call\\n-\\nOtherwise insert command i executed\\nAs shown in the following code section\\nWe can separate this part in a function because we will use it multiple times\\nNow you can load from database using the following function that maps each row\\nin a new instance\\nUse future builder to load the previously added places from storage\\nUsage of future builder\nGenerate 2 multiple choice question with four answers and one answer only is correct",
        "output: {\n  \"questions\": [\n    {\n      \"question\": \"Which package is used in Flutter to access the system directory for storing files?\",\n      \"options\": [\n        \"A) sqflite\",\n        \"B) path_provider\",\n        \"C) path\",\n        \"D) storage_manager\"\n      ],\n      \"correct_answer\": \"B) path_provider\"\n    },\n    {\n      \"question\": \"What is the purpose of the Oncreate command in the context of using SQLite in Flutter?\",\n      \"options\": [\n        \"A) It retrieves the system directory to store files.\",\n        \"B) It opens the database file places.db.\",\n        \"C) It is executed only at the first call to set up the database schema.\",\n        \"D) It inserts data into the database.\"\n      ],\n      \"correct_answer\": \"C) It is executed only at the first call to set up the database schema.\"\n    }\n  ]\n}",
        "input: Lecture 1: Mobile \\nProgramming using Flutter\\nDr.Taraggy Ghanim \\nWhat is Flutter?\\nFrom Flutter Code to Plateform Code\\nFlutter Is Not A Programming Language!\\nPlatforms Supported by Flutter\\nTarget Platforms\\nYou can write the code of all platforms on the same machine.\\nYou can only test and run  ios & macos on macos machine.\\nYou can only test and run Windows app on Windows machine. \\nYou can only test and run Linux app on Linux machine.\\nAndroid and Web apps can be built on any machine\\nTarget Platform Tools &Devices Setup\\nFlutter.dev\\nFlutter Installation For Windows\\nGit Setup\\nGit Setup\\nGit Setup\\nGit Setup\\nGit Setup\\nGit Setup\\nGit Setup \\nAfter Git Installation Go to next Step…….Flutter sdk\\nExtract the zipped ﬁle \\nImportant Notes\\nEdit environmental variables \\nUpdate your path: OS should be aware of the ﬂutter tools\\nEdit System Environment Variables \\nEnvironment Variables \\nCheck the Path\\nCreate path if doesn't exist\\nEdit path if exist\\nPress Edit and then New\\nWrite the bin path\\nRun Flutter Doctor in the command Window \\nRun Flutter Doctor in the command Window \\nMake sure that ﬂutter is correctly downloaded \\nDownload Android Studio\\nDeveloper.android\\nChoose the Android Virtual Device is installed (emulator)\\nRemember the path\\nConﬁguration: choose custom\\nIf Android Virtual Device is unavailable, continue without it \\nAfter Installation: more actions→sdk manager\\nSdk Platforms \\nSdk Tools → apply then next\\nVirtual Device Manager\\nCreate Device \\nChoose any template for your emulator \\nChoose the latest\\nChoose hardware then click ﬁnish\\nCreate new folder anywhere ( without spaces or dash)\\nOpen in terminal ( command prompt)\\nFlutter create command\\nFlutter run command\\nVS code installation \\nOpen Folder\\nView- Extensions\\nFlutter Extension \\nPut dart code in lib\\nSamplec code\\nView - Command Pallete\\nCommand pallete\\nView- Appearance- status bar\\nRun\\nRun from terminal \\nRun from terminal \\nRun without Debugging\\nText Widget \\nBefore and After Saving Changes\\nIf changes doesn't appear, you can force ﬂutter to ﬁnd \\nchanges or restart the code \\nImportant links\\nhttps://docs.flutter.dev/get-sta\\nrted/install/windows\\nhttps://github.com/academind/flu\\ntter-complete-guide-course-resou\\nrces/tree/main/Lecture%20Attachm\\nents\\nhttps://github.com/academind/flu\\ntter-complete-guide-course-resou\\nrces\\nStarting our First Program \\nimport 'package:flutter/material.dart'\\n material.dart library contains a set of pre-built \\nwidgets that implement the Material Design \\nguidelines.\\nMaterial Design is an open-source design system \\nbuilt and supported by Google designers and \\ndevelopers.\\nmain()   runApp() functions\\nthe main() function is used to start the program. \\nrunApp() function is used to return the widgets that are connected to the screen as the \\nroot of the widget tree to be rendered on the screen.\\nWhat are Widgets ? \\nEach element on a screen of the Flutter app is a \\nwidget. Each widget is a  part of a user interface \\nWidget Tree : position widgets within each other to build \\nsimple and complex layouts\\nWidget Tree\\nCategory of Widgets:\\nThere are mainly 14 categories in which the ﬂutter widgets are divided. They are mainly segregated on the basis of the \\nfunctionality they provide in a ﬂutter application.\\n1.\\nAccessibility: These are the set of widgets that make a ﬂutter app more easily accessible.\\n2.\\nAnimation and Motion: These widgets add animation to other widgets.\\n3.\\nAssets, Images, and Icons: These widgets take charge of assets such as display images and show icons.\\n4.\\nAsync: These provide async functionality in the ﬂutter application.\\n5.\\nBasics: These are the bundle of widgets that are absolutely necessary for the development of any ﬂutter application.\\n6.\\nCupertino: These are the iOS designed widgets.\\n7.\\nInput: This set of widgets provides input functionality in a ﬂutter application.\\n8.\\nInteraction Models: These widgets are here to manage touch events and route users to different views in the application.\\n9.\\nLayout: This bundle of widgets helps in placing the other widgets on the screen as needed.\\n10.\\nMaterial Components: This is a set of widgets that mainly follow material design by Google.\\n11.\\nPainting and effects: This is the set of widgets that apply visual changes to their child widgets without changing their layout or \\nshape.\\n12.\\nScrolling: This provides scrollability of to a set of other widgets that are not scrollable by default.\\n13.\\nStyling: This deals with the theme, responsiveness, and sizing of the app.\\n14.\\nText: This displays text.\\nTypes of Widgets:\\n1.\\nStateless Widget\\n2.\\nStateful Widget\\nMaterialApp → widget that wraps a number of widgets\\nRemove the debug Banner\\nBool useMaterial3→ updated version than material 2 with \\nmore effects and colors\\nHome \\nproperty: \\ndisplayed ﬁrst \\nwhen the \\napplication is \\nstarted normally\\nStatefulWidget related to State Class\\nEach time \\nsetState is \\ncalled, the \\nbuild \\nfunction is \\nre-excuted\\nfat arrow notation \\n( => ).  A fat arrow \\nis used to deﬁne a \\nsingle expression \\nin a function. This \\nis a cleaner way to \\nwrite functions \\nwith a single \\nstatement.\\n_ means \\nprivate \\nmember\\nScaffold \\nScaffold is a class in flutter which \\nprovides many widgets \\n APIs like Drawer, Snack-Bar, \\nBottom-Navigation-Bar, \\nFloating-Action-Button, App-Bar,\\nScaffold will expand or occupy the whole \\ndevice screen. It will occupy the available \\nspace.\\nhttps://docs.flutter.dev/cookbook/design/drawer\\nhttps://docs.flutter.dev/cookbook/design/snackbars\\nAppBar\\nExercise : \\nWrite the following \\nCode in your class \\nExercise\\nHomeWork: \\nDescribe the code in \\ncomments\\nCenter \\nA widget that centers its child within itself.\\nThis widget will be as big as possible if its dimensions are constrained and widthFactor and heightFactor are null. If a \\ndimension is unconstrained and the corresponding size factor is null then the widget will match its child's size in that \\ndimension. If a size factor is non-null then the corresponding dimension of this widget will be the product of the child's \\ndimension and the size factor. For example if widthFactor is 2.0 then the width of this widget will always be twice its child's \\nwidth.\\nColumn\\nA widget that displays its children in a vertical array.\\nTo cause a child to expand to ﬁll the available vertical space, wrap the child in an Expanded widget.\\nThe Column widget does not scroll (and in general it is considered an error to have more children in a Column than will ﬁt in \\nthe available room). If you have a line of widgets and want them to be able to scroll if there is insuﬃcient room, consider \\nusing a ListView.\nGenerate 3 medium true/false questions with their answers",
        "output: {\n  \"questions\": [\n    {\n      \"question\": \"Flutter is a programming language specifically designed for mobile app development.\",\n      \"answer\": \"False\"\n    },\n    {\n      \"question\": \"You can develop Android and web apps using Flutter on any machine, regardless of the operating system.\",\n      \"answer\": \"True\"\n    },\n    {\n      \"question\": \"Stateless widgets in Flutter are used when the UI needs to dynamically update based on user interactions or data changes.\",\n      \"answer\": \"False\"\n    }\n  ]\n}",
        "input: input: Selected topics in Requirements Engineering\\nA p p l i e d  S o f t w a r e  E n g i n e e r i n g\\nRequirements Engineering Processes:\\nRequirements Specification, .. & ..\\nthe Software Requirements Document\\nWhat is Requirements Specification?\\nWriting a System Requirements Specification\\n• Natural Language Specification: Guidelines & Problems\\n• Structured Specifications: Form-based Specifications\\n• Tabular Specification\\n• Graphical Models: Use-Cases\\nThe Structure of a Requirements Document [ SRS ]\\nRequirements Specification\\n2\\nThe process of writing down the user and system requirements\\nin a requirements document.\\n✓ User requirements must be understandable by end-users and customers who do not have a technical background.\\n✓ System requirements are more detailed requirements and may\\ninclude more technical information.\\n✓ The requirements may be part of a contract for the system\\ndevelopment (It is therefore important that these are as\\ncomplete as possible).\\nRequirements Specification\\nDefinition of a Requirement Expression\\n3\\nA Requirement Expression includes a requirement statement\\nwith a set of associated attributes.\\n[SH234] The ambulance control system shall be able to handle up\\nto 100 simultaneous emergency calls.\\nSource:\\nR. Thomas\\nPriority:\\nMandatory\\nRelease:\\n1\\nReview Status: Accepted\\nVerifiable:\\nYes\\nVerification:\\nBy simulation, then by a system test.\\nNotation\\nDescription\\nNatural\\nLanguage\\nThe\\nrequirements\\nare\\nwritten\\nusing\\nnumbered\\nsentences\\nin\\nnatural\\nlanguage. Each sentence should express one requirement.\\nStructured\\nNatural\\nLanguage\\nThe requirements are written in natural language on a standard form or\\ntemplate.\\nEach\\nfield\\nprovides\\ninformation\\nabout\\nan\\naspect\\nof\\nthe\\nrequirement.\\nDesign\\nDescription\\nLanguages\\nThis approach uses a language like a programming language, but with more\\nabstract features to specify the requirements by defining an operational\\nmodel of the system. This approach is now rarely used although it can be\\nuseful for interface specifications.\\nGraphical\\nNotations\\nGraphical models, supplemented by text annotations, are used to define the\\nfunctional requirements for the system; UML use case and sequence\\ndiagrams are commonly used.\\nMathematical\\nSpecifications\\nThese notations are based on mathematical concepts such as finite-state\\nmachines or sets. Although these unambiguous specifications can reduce\\nthe\\nambiguity\\nin\\na\\nrequirements\\ndocument,\\nmost\\ncustomers\\ndon’t\\nunderstand a formal specification. They cannot check that it represents what\\nthey want and are reluctant to accept it as a system contract\\nRequirements Specification\\nWays of Writing\\n4\\nRequirements Specification\\nWays of Writing [ Natural Language Spec. ]\\n5\\nRequirements\\nare\\nwritten\\nas\\nnatural\\nlanguage\\nsentences\\nsupplemented by diagrams and tables.\\n•\\nUsed for writing requirements because it is expressive, intuitive\\nand universal. This means that the requirements can be\\nunderstood by users and customers.\\nRequirements Specification\\nWays of Writing [ Natural Language Spec. ]\\n6\\nProblems with Natural Language:\\n1.\\nLack of Clarity; Precision is difficult without making the document\\ndifficult to read.\\n2.\\nRequirements Amalgamation; Several different requirements may\\nbe expressed together.\\n3.\\nRequirements\\nConfusion;\\nFunctional\\nand\\nNon-Functional\\nrequirements tend to be mixed-up.\\nGuidelines for Writing Requirements:\\n1.\\nInvent a standard format and use it for all requirements.\\n2.\\nUse language in a consistent way. Use shall for mandatory\\nrequirements, should for desirable requirements.\\n3.\\nUse text highlighting to identify key parts of the requirement.\\n4.\\nAvoid the use of computer jargon.\\n5.\\nInclude an explanation (rationale) of why a requirement is\\nnecessary.\\nRequirements Specification\\nWays of Writing [ Natural Language Spec. ]\\nExample: Requirements for the Insulin Pump Software System\\n7\\nRequirements Specification\\nWays of Writing [ Natural Language Spec. ]\\nExample: Requirements for the Insulin Pump Software System\\n8\\n3.2 The system shall measure the blood sugar and deliver\\ninsulin, if required, every 10 minutes. (Changes in blood sugar\\nare\\nrelatively\\nslow\\nso\\nmore\\nfrequent\\nmeasurement\\nis\\nunnecessary;\\nless\\nfrequent\\nmeasurement\\ncould\\nlead\\nto\\nunnecessarily high sugar levels.)\\n3.6 The system shall run a self-test routine every minute with\\nthe conditions to be tested and the associated actions defined\\nin Table 1. (A self-test routine can discover hardware and\\nsoftware problems and alert the user to the fact the normal\\noperation may be impossible.)\\nRequirements Specification\\nWays of Writing [ Structured Specifications ]\\n9\\nAn approach to writing requirements where the freedom of the\\nrequirements writer is limited, and requirements are written in\\na standard way.\\no This works well for some types of requirements (e.g.,\\nrequirements\\nfor\\nan\\nembedded\\ncontrol\\nsystem),\\nbut\\nis\\nsometimes too rigid for writing business system requirements.\\nRequirements Specification\\nWays of Writing [ Structured Specifications ]\\n10\\nFor Example: Form-based specifications\\no Definition of the function or entity.\\no Description of inputs and where they come from.\\no Description of outputs and where they go to.\\no Information\\nabout\\nthe\\ninformation\\nneeded\\nfor\\nthe\\ncomputation and other entities used.\\no Description of the action to be taken.\\no Pre- conditions and post-conditions (if appropriate).\\no The side effects (if any) of the function.\\nRequirements Specification\\nWays of Writing [ Structured Specifications ]\\nExample: Requirements for the Insulin Pump Software System\\n11\\nInsulin Pump/Control Software/SRS/3.3.2 \\nFunction Compute insulin dose: safe sugar level. \\nDescription \\n \\nComputes the dose of insulin to be delivered when the current \\nmeasured sugar level is in the safe zone between 3 and 7 units. \\nInputs Current sugar reading (r2); the previous two readings (r0 \\nand r1). \\nSource \\nCurrent sugar reading from sensor. Other readings \\nfrom memory. \\nOutputs \\nCompDose—the dose in insulin to be delivered. \\nDestination   Main control loop. \\n \\nRequirements Specification\\nWays of Writing [ Structured Specifications ]\\n12\\nAction  \\nCompDose is zero if the sugar level is stable or falling or if the \\nlevel is increasing but the rate of increase is decreasing. If the \\nlevel is increasing and the rate of increase is increasing, then \\nCompDose is computed by dividing the difference between the \\ncurrent sugar level and the previous level by 4 and rounding the \\nresult. If the result, is rounded to zero then CompDose is set to \\nthe minimum dose that can be delivered.  \\nRequirements  \\nTwo previous readings so that the rate of change of sugar level \\ncan be computed. \\nPre-condition   \\nThe insulin reservoir contains at least the maximum allowed \\nsingle dose of insulin. \\nPost-condition  \\nr0 is replaced by r1 then r1 is replaced by r2. \\nSide effects \\n None. \\nRequirements Specification\\nWays of Writing [ Structured Specifications ]\\nE.g., Volere Requirements Shell\\n13\\nRequirements Specification\\nWays of Writing [ Tabular Specification ]\\n14\\nUsed to supplement natural language.\\nParticularly useful when you must define several possible\\nalternative courses of action.\\nFor example, the insulin pump systems bases its computations on\\nthe rate of change of blood sugar level and the tabular\\nspecification explains how to calculate the insulin requirement for\\ndifferent scenarios.\\nRequirements Specification\\nWays of Writing [ Tabular Specification ]\\nExample: Requirements for the Insulin Pump Software System\\nComputation for the Insulin Pump:\\n15\\nCondition\\nAction\\nSugar level falling ( r2 < r1 )\\nCompDose = 0\\nSugar level stable ( r2 = r1 )\\nCompDose = 0\\nSugar level increasing & rate of increase decreasing\\n( ( r2 – r1 ) < ( r1 – r0 ) )\\nCompDose = 0\\nSugar level increasing & rate of increase stable or increasing\\n( ( r2 – r1 ) ≥ ( r1 – r0 ) )\\nCompDose =\\nround ( ( r2 – r1 ) / 4 )\\nIf rounded result = 0 then\\nCompDose = MinimumDose\\nRequirements Specification\\nWays of Writing [ Graphical Models ]\\nExample: an ATM System\\n– A Use Case Diagram\\n(top level use cases)\\n16\\nThe Software Requirements Document\\n17\\nThe software requirements document is the official statement of\\nwhat is required of the system developers.\\n•\\nShould include both a definition of user requirements and a\\nspecification of the system requirements.\\n•\\nIt is NOT a design document. As far as possible, it should set of\\nWHAT the system should do rather than HOW it should do it.\\nNote: Information in Requirements Document depends on the\\ntype of system and the approach to development used (for\\ninstance, systems developed incrementally will, typically, have less\\ndetail in the requirements document).\\nThe Software Requirements Document\\n18\\nTypical Users of\\na Requirements\\nDocument:\\nThe Software Requirements Document\\nTypical Structure of a Requirements Document:\\n19\\nChapter\\nDescription\\nPreface\\nThis should define the expected readership of the document and describe its\\nversion history, including a rationale for the creation of a new version and a\\nsummary of the changes made in each version.\\nIntroduction\\nThis should describe the need for the system. It should briefly describe the\\nsystem’s functions and explain how it will work with other systems. It should also\\ndescribe how the system fits into the overall business or strategic objectives of the\\norganization commissioning the software.\\nGlossary\\nThis should define the technical terms used in the document. You should not make\\nassumptions about the experience or expertise of the reader.\\nUser\\nRequirements\\nDefinition\\nHere, you describe the services provided for the user. The nonfunctional system\\nrequirements should also be described in this section. This description may use\\nnatural language, diagrams, or other notations that are understandable to\\ncustomers. Product and process standards that must be followed should be\\nspecified.\\nSystem\\nArchitecture\\nThis chapter should present a high-level overview of the anticipated system\\narchitecture,\\nshowing\\nthe\\ndistribution\\nof\\nfunctions\\nacross\\nsystem\\nmodules.\\nArchitectural components that are reused should be highlighted.\\nThe Software Requirements Document\\nTypical Structure of a Requirements Document:\\n20\\nChapter\\nDescription\\nSystem\\nRequirements\\nSpecification\\nThis should describe the functional and nonfunctional requirements in more detail.\\nIf necessary, further detail may also be added to the nonfunctional requirements.\\nInterfaces to other systems may be defined.\\nSystem\\nModels\\nThis might include graphical system models showing the relationships between the\\nsystem components and the system and its environment. Examples of possible\\nmodels are object models, data-flow models, or semantic data models.\\nSystem\\nEvolution\\nThis should describe the fundamental assumptions on which the system is based,\\nand any anticipated changes due to hardware evolution, changing user needs, and\\nso on. This section is useful for system designers as it may help them avoid design\\ndecisions that would constrain likely future changes to the system.\\nAppendices\\nThese should provide detailed, specific information that is related to the application\\nbeing developed; for example, hardware and database descriptions. Hardware\\nrequirements define the minimal and optimal configurations for the system.\\nDatabase requirements define the logical organization of the data used by the\\nsystem and the relationships between data.\\nIndex\\nSeveral indexes to the document may be included. As well as a normal alphabetic\\nindex, there may be an index of diagrams, an index of functions, and so on.\\nThe Software Requirements Document\\nExamples of a Requirements Document:\\n21\\n► Requirements for the MentCare System (a system to support the \\nclinical management of patients suffering from mental illness): \\nhttps://iansommerville.com/software-engineering-book/case-studies/mentcare/\\n► Software Requirements Specification for a Web Publishing System:\\nhttps://www.cse.msu.edu/~cse435/Handouts/SRSExample-webapp.doc\\n► A Personal Insulin Pump:\\n•\\nCase Study details: https://iansommerville.com/software-engineering-\\nbook/case-studies/insulin-pump/\\n•\\nInsulin Pump – an Overview: \\nhttps://www.dropbox.com/s/tzc8shdjmrqo4cz/InsulinPumpOverview.pdf?dl=0\\n•\\nRequirements for the Insulin Pump: \\nhttps://www.dropbox.com/s/grgaaxtdas4oj1i/InsulinPumpRequirements.pdf?\\ndl=0\\nThe Software Requirements Document\\nExamples of a Requirements Document:\\n22\\n► Flight Control System (Airbus 340); System Specification that\\ndescribes the architecture of the Airbus 340 flight control system, a\\nsafety critical system that implements the fly-by-wire flight system on\\nthe Airbus.\\n•\\nFlight Control System (Airbus 340) - Overview:\\nhttps://www.slideshare.net/software-engineering-book/airbus-fcs-42647819\\n•\\nFlight Control System (Airbus 340) - System Specification [ Part 1 ]: \\nhttps://www.dropbox.com/s/o6d7056eh3bvv9u/FCS1.pdf?dl=0\\n•\\nFlight Control System (Airbus 340) - System Specification [ Part 2 ]: \\nhttps://www.dropbox.com/s/jbe0ajlhxotvqn2/FCS2.pdf?dl=0\\n.. + More Examples/Samples in the description below the video.\\nThe Unified Modelling Language\\nThe Diagrams\\n a UML Model\\n the UML Diagrams – A Rough Categorization\\n the 7 Structural [ Static ] Diagrams\\n the 7 Behavioral [ Dynamic ] Diagrams\\nSelected topics in System / Software Modelling\\nA p p l i e d  S o f t w a r e  E n g i n e e r i n g\\n2\\nthe UML Diagrams –A Rough Categorization\\nThe Concept\\nA taxonomy (a very rough categorization) \\nof the 14 UML diagrams, differentiating \\nbetween structure (static) diagrams and \\nbehavior (dynamic) diagrams*.\\n* Object Management Group. OMG Unified Modeling Language (UML), \\nSuper- structure. Technical Report Version 2.4.1, OMG, August 2011.\\n3\\nStatic [ Structural ] Modelling\\nThe Concept\\nUML offers seven types of\\ndiagrams for modeling the\\nstructure of a system from\\ndifferent perspectives. The\\ndynamic\\nbehavior\\nof\\nthe\\nelements in question (i.e.,\\ntheir changes over time) is\\nnot\\nconsidered\\nin\\nthese\\ndiagrams.\\n4\\nBehavior [ Dynamic ] Modelling\\nThe Concept\\nUML offers seven types of\\ndiagrams for modeling the\\nbehavior of a system from\\ndifferent perspectives.\\nWith the behavior diagrams,\\nUML offers the structure\\nthat enables us to define\\nbehavior in detail.\\nBehavior refers to the direct\\nconsequences of an action\\nof at least one object. It\\naffects how the states of\\nobjects change over time.\\nBehavior\\ncan\\neither\\nbe\\nspecified\\nthrough\\nthe\\nactions of a single object or\\nresult\\nfrom\\ninteractions\\nbetween multiple objects.\\nUSE-CASE MODELS\\n.. introduces a means of defining what a proposed system should do from a user’s\\nperspective.\\no This can provide the basis for a contract between the customer and the developer\\no Your aim is to construct a software system that will meet the needs of its users.\\nHence you must identify ‘who does what’.\\no To do this, you explore the problem description, any domain models and the\\ninitial set of user requirements to determine the people involved, the work that they\\ndo and the events that trigger some work to be done.\\no You are likely to identify a variety of people, some of whom may be playing a\\nnumber of different roles and may be associated with different business events.\\no You should ask yourself who the actual users will be and what tasks they must\\nperform with the aid of your software system.\\nFROM DOMAIN TO REQUIREMENTS; USE-CASE & ACTIVITY DIAGRAMS\\n27\\nUSE-CASE MODELS .. ADVANTAGES\\no Capturing and eliciting requirements;\\no Representing requirements;\\no Planning iterations of development;\\no Validating software systems.\\no Defining the scope of a system, as they represent the interaction of\\na system with its environment.\\no Acting as a discussion tool between developer and user, and offer\\na common language for agreeing on the functions of the software\\nsystem.\\nFROM DOMAIN TO REQUIREMENTS; USE-CASE & ACTIVITY DIAGRAMS\\n28\\nUSE-CASE MODELS .. ELEMENTS & SYMBOLS\\nFROM DOMAIN TO REQUIREMENTS; USE-CASE & ACTIVITY DIAGRAMS\\n29\\nUSE-CASE MODELS .. DESCRIPTIONS\\nEach use case description should contain the following parts in minimum:\\n- Use case identifier and name\\n- Initiator: name of the actor who initiates the process\\n- Pre-condition(s): a condition that must hold before this use case can be carried\\nout..\\n- Post-condition(s): a condition that must hold after the use case has been\\ncompleted.\\n- Main Success Scenario: a single sequence of steps that describe the main success\\nscenario. You can number the steps. A scenario is an instance of a use case.\\n- Goal: a short description of the goal of the use case;\\nExceptions to the normal behavior for a use case are common, especially where\\nactors decide to cancel a use case without completing it.\\nFROM DOMAIN TO REQUIREMENTS; USE-CASE & ACTIVITY DIAGRAMS\\n30\\nUSE-CASE DIAGRAMS .. EXAMPLE 1\\nA simple use \\ncase diagram \\nfor the main \\ntasks in a hotel \\nsystem: make \\nreservation, \\ncheck-in, and \\ncheck-out, \\nwhere the \\nreservation can \\nbe done by the \\nreceptionist or a \\nguest (by \\nPhone/Web). \\nFROM DOMAIN TO REQUIREMENTS; USE-CASE & ACTIVITY DIAGRAMS\\n31\\nUSE-CASE DIAGRAMS .. SYSTEM BOUNDARY\\nThe system boundary determines the scope of the system. \\no It\\ndistinguishes\\nbetween\\ninternal\\nand\\nexternal\\ncomponents.\\no The external components are actors and the internal\\ncomponents are the use cases.\\no In UML it is optional to use system boundary notation.\\no A solid box drawn around the use cases with the actors\\nlocated outside it represents the system boundary.\\no We use system boundary notation when the system is\\ncomplex and includes several subsystems.\\nFROM DOMAIN TO REQUIREMENTS; USE-CASE & ACTIVITY DIAGRAMS\\n32\\nUSE-CASE DIAGRAMS .. SYSTEM BOUNDARY\\nFROM DOMAIN TO REQUIREMENTS; USE-CASE & ACTIVITY DIAGRAMS\\n33\\nUSE-CASE DESCRIPTIONS\\nA scenario describes a sequence of interactions between the system and some\\nactors.\\no In Each use case there is a set of possible scenarios. Where the main scenario\\nis the successful scenario where nothing goes wrong and the use case is\\nachieved.\\nFor example: there are two scenarios for making reservation in a hotel:\\nMain Success Scenario:\\no The guest wants to reserve a double room at the Hotel for 14 July. A double\\nroom is available for that date, and the reservation is done.\\nUnsuccessful Scenario:\\no The guest wants to reserve a single room at the Hotel for the first week of\\nAugust. There is no single room that is free for seven days in August, but there\\nis one room available for four days and another one for the following three\\ndays. The system presents that option to the guest, who rejects it.\\nFROM DOMAIN TO REQUIREMENTS; USE-CASE & ACTIVITY DIAGRAMS\\n34\\nUSE-CASE DESCRIPTIONS\\nWhat pre and post condition(s) you can obtain from the below description\\nof a hotel check-in process?\\nUpon arrival, each guest provides the reservation number for his or her\\nreservation to the hotel’s receptionist, who enters it into the software system.\\nThe software system reveals the details of that reservation so that each guest\\ncan confirm them. The software system allocates an appropriate room to that\\nguest and opens a bill for the duration of the stay. The receptionist issues a\\nkey for the room.\\nPrecondition(s): There must be a reservation for the guest, and there must be\\nat least one room available (of the desired type), and the guest must be able\\nto pay for the room.\\nPost-condition(s): The guest will have been allocated to a room for the\\nperiod identified in the reservation, the room will have been identified as\\nbeing in use for a specific period, a bill will have been opened for the\\nduration of the stay, and a key will have been issued.\\nFROM DOMAIN TO REQUIREMENTS; USE-CASE & ACTIVITY DIAGRAMS\\n35\\nUSE-CASE \\nDESCRIPTIONS\\nFROM DOMAIN TO REQUIREMENTS; USE-CASE & ACTIVITY DIAGRAMS\\n36\\nUSE-CASE SCENARIOS\\nFor each use case there is a set of possible scenarios. A scenario is an instance\\nof a use case. A scenario describes a sequence of interactions between the\\nsystem and some actors. Here are two examples of scenarios.\\no A member of a lending library wishes to borrow a book, and is allowed to\\ndo that as long as they have no outstanding loans.\\no Another member wishes to borrow a book, but has exceeded the quota for\\nthe number of books that can be borrowed.\\nIn each scenario the member wishes to borrow a book, but both the circumstances\\nand outcomes of events are different in each instance.\\nA use case includes a complex set of requirements that the system must meet in\\norder to cope with every eventuality.\\nThe main success scenario shows the steps normally followed to achieve the\\nstated goal of the use case. But there can be other scenarios for the same use\\ncase, each one having different outcomes depending upon circumstances.\\nFROM DOMAIN TO REQUIREMENTS; USE-CASE & ACTIVITY DIAGRAMS\\n37\\nUSE-CASE MODELS .. \\nGENERALIZATION AMONG ACTORS\\nUML provides a notation to use generalisation between actors.\\n- When two actors share the same behaviour (interacting with the same use\\ncases) and one of them has some extra behaviour, then the common behaviour\\ncan be associated with a generalised actor and the more specific behaviour\\nwith the specialised actor.\\nFor example, in the hotel system both the receptionist and the guest are\\nallowed to make reservation.\\n- Guest can make reservation through online system;\\n- the receptionist can do reservation on behalf of guest when a guest do\\nreservation through phone or a fax.\\nFROM DOMAIN TO REQUIREMENTS; USE-CASE & ACTIVITY DIAGRAMS\\n38\\nUSE-CASE MODELS .. \\nGENERALIZATION AMONG \\nACTORS\\nFROM DOMAIN TO REQUIREMENTS; USE-CASE & ACTIVITY DIAGRAMS\\n39\\nWe introduce a new actor called \\nReserver associated with the \\nmake reservation use case. \\n-\\nThe actors Guest and \\nReceptionist specializes \\nReserver. \\n-\\nGuest can do the same things \\nthat a Reserver can, but may \\ndo other things too.\\n-\\nBy using the open-headed \\narrow from Guest to Reserver, \\nyou are saying that a Guest \\ncan do the same things that a \\nReserver can, but may do \\nsomething else that a \\nReserver does not. Reserver is \\na generalised actor and \\nGuest a specialised one. \\nUSE-CASE MODELS .. \\nRELATIONSHIPS BETWEEN USE-CASES\\nUse cases can be related to one another. There are two very common and\\nimportant forms of relationship between use cases: inclusion and extension.\\nInclusion: This is when two or more use cases have a common area of\\nfunctionality that can be factored out as a distinct use case.\\nThe new use case can be used by each of the original use cases, so avoiding\\nduplication.\\nExtension: This is when a use case has a main success scenario but also\\nalternative scenarios which demand a variation on the original use case –\\ndifferent or additional actions.\\nEach variation can be separated out as a use case that is distinct from but\\nrelated to the original use case.\\nAn extension is conditional while an inclusion is not.\\nIn UML we use «include» and «extend» stereotypes for representing inclusion\\nand extension.\\nFROM DOMAIN TO REQUIREMENTS; USE-CASE & ACTIVITY DIAGRAMS\\n40\\nUSE-CASE MODELS .. \\n«INCLUDE» .. SHARING BEHAVIOUR\\nIn the process of eliciting and specifying requirements, you may\\nfind a certain amount of common behaviour in two or more of\\nyour use cases.\\n- You can record the shared behaviour in a new use case and\\nconnect it to the use cases that it came from with a dashed arrow\\n(indicating a dependency relationship) pointing from the original\\nuse case to the new one.\\n- Hence the dependency arrow is labelled with the «include»\\nstereotype.\\nFROM DOMAIN TO REQUIREMENTS; USE-CASE & ACTIVITY DIAGRAMS\\n41\\nUSE-CASE MODELS .. \\n«INCLUDE» .. EXAMPLE\\nMembers of a lending library can borrow a certain number of books and, for\\nany book borrowed, renew the loan up to three times. A loan can only be\\nrenewed if there are no existing reservations for that book by other members,\\nwhen all other copies are on loan.\\nLet us assume that when a member returns a book there must be a check to\\nsee whether there are outstanding reservations for that book by other\\nmembers. In this case the book will not be returned to the shelf, but will instead\\nbe assigned to the highest priority reservation.\\nThis same check needs to be carried out when a member extends a loan. The\\nreservation check is a shared piece of behaviour, a common scenario, which\\ncan be developed separately as the check reservation use case.\\nNote that this is unconditional behaviour – the reservation check must be\\nperformed whenever a loan is extended or a book is returned. A dependency\\narrow has a source (where it comes from) and a target (where it goes to).\\nFROM DOMAIN TO REQUIREMENTS; USE-CASE & ACTIVITY DIAGRAMS\\n42\\nUSE-CASE MODELS .. \\n«INCLUDE» .. EXAMPLE\\nFROM DOMAIN TO REQUIREMENTS; USE-CASE & ACTIVITY DIAGRAMS\\n43\\nUSE-CASE MODELS .. \\n«EXTEND» ALTERNATIVES TO MAIN SCENARIOS\\nThe «extend» stereotype indicates a conditional extension to the original use\\ncase, known as alternative behaviour.\\n- This is used to illustrate a case where there are two or more significantly\\ndifferent scenarios, so that the main case and the additional subsidiary cases are\\nclearly differentiated. The main purpose of this classification is to separate out a\\nspecial case.\\n- You should add a condition to each extension – by a note for instance – to\\nspecify when the variant behaviour will be included.\\n- This could be done with either a note or an extension point.\\n- The new use case (Alternative one) depends on the original. This is a conditional\\nbehavior.\\n- The new use case (the source) is connected to the original (the target) with a\\ndashed arrow pointing to the original and labelled with the stereotype «extend».\\nFROM DOMAIN TO REQUIREMENTS; USE-CASE & ACTIVITY DIAGRAMS\\n44\\nUSE-CASE MODELS .. \\n«EXTEND» .. EXAMPLE\\nA typical lending library will set an upper limit on the number of\\nbooks that its members can borrow at any one time. A librarian\\nwill not be allowed to issue a copy of a book if that limit would\\nbe exceeded.\\n- The next figure shows a fragment of a use case diagram that\\nidentifies a new use case, refuse loan, as it is only performed\\nwhen the member would have too many books.\\nNote that: the refuse loan is a conditional behavior which is\\nonly performed when the member would have too many books.\\nThe note symbol is used to record the event that trigger the\\nsubsidiary use case.\\nFROM DOMAIN TO REQUIREMENTS; USE-CASE & ACTIVITY DIAGRAMS\\n45\\nUSE-CASE MODELS .. \\n«EXTEND» .. EXAMPLE\\nFROM DOMAIN TO REQUIREMENTS; USE-CASE & ACTIVITY DIAGRAMS\\n46\\nUSE-CASE MODELS .. \\nEXTENDING \\nDESCRIPTIONS\\nFROM DOMAIN TO REQUIREMENTS; USE-CASE & ACTIVITY DIAGRAMS\\n47\\nUSE-CASE MODELS .. \\nTO EXTEND OR TO INCLUDE?\\nWe could show the log on use-case as a component of every \\nuse case that is associated with an actor.\\nExtend or Include?\\nFROM DOMAIN TO REQUIREMENTS; USE-CASE & ACTIVITY DIAGRAMS\\n48\\nUSE-CASE MODELS .. \\nTO EXTEND OR TO INCLUDE?\\nNote that: there is no \\nimplication of \\nordering: time \\nordering is not shown \\nin use-case diagrams. \\nFROM DOMAIN TO REQUIREMENTS; USE-CASE & ACTIVITY DIAGRAMS\\n49\\nUSE-CASE MODELS .. \\nAVOIDING OVER-COMPLEX USE CASE DIAGRAMS\\nThe general approach to managing complexity is to partition a problem into\\nsub-problems, and use abstraction to reduce the detail and extract what is\\nmost significant to the problem.\\nReduce the complexity of your use-case diagram by:\\n1. redrawing it at a higher level of abstraction\\n2. splitting it up into smaller modules.\\nExample: In the case of the hotel chain, we might partition our solution into\\nthree sub-problems, usually called packages (a way of grouping cases):\\n1. reservations, 2. checking guests in and out of their rooms, 3. system access\\nEach\\npackage\\nmay\\nthen\\nbe\\nassigned\\nto\\na\\nseparate\\ndeveloper\\nfor\\nimplementation, the project team must then deal with the dependencies\\nbetween the three packages as they work towards a solution..\\nFROM DOMAIN TO REQUIREMENTS; USE-CASE & ACTIVITY DIAGRAMS\\n50\\nUSE-CASE AS A PLANNING AID\\nOne of the difficulties that developers face is planning delivery times.\\nThe use case descriptions help the developer to:\\n❑ Understand the complexity of each use case.\\n❑ Determine which actors interact with each use case and to what extent.\\n❑ Establish which use cases carry the most risk.\\n❑ Estimate how long each use case is likely to take to implement.\\nFROM DOMAIN TO REQUIREMENTS; USE-CASE & ACTIVITY DIAGRAMS\\n51\\nUSE-CASE .. & ARCHITECTURE\\no Use cases, as standalone chunks of system specification, dictate the sorts of\\nfunctionality that need to be provided by the system and constitute an aid for\\nidentifying interfaces in an architecture.\\no Use cases can also be grouped in terms of similar functionality, therefore\\ninfluencing the architecture of the system.\\no Scenarios can be used to check how an architecture meets non-functional\\nrequirements, in particular those that can be affected by the architecture, such\\nas security and safety requirements.\\nFROM DOMAIN TO REQUIREMENTS; USE-CASE & ACTIVITY DIAGRAMS\\n52\\nUSE-CASE .. & TESTING\\no One way to validate a system is to use the walk-through technique, checking\\nthe functionality related to each use case in turn.\\no The walkthrough technique can also be used to elicit system tests where each\\nuse case is required to deal with a number of scenarios – a process known as\\nverification.\\nFROM DOMAIN TO REQUIREMENTS; USE-CASE & ACTIVITY DIAGRAMS\\n53\nGenerate 3 hard multiple choice questions with four answers and one answer only is correct",
        "output: {\n  \"questions\": [\n    {\n      \"question\": \"What is the primary purpose of a Requirements Specification document?\",\n      \"options\": [\n        \"a) To outline the design decisions of the system\",\n        \"b) To specify how the system will be implemented\",\n        \"c) To document the user and system requirements\",\n        \"d) To describe the system's testing procedures\"\n      ],\n      \"correct_answer\": \"c) To document the user and system requirements\"\n    },\n    {\n      \"question\": \"Which notation is commonly used for writing natural language specifications in requirements engineering?\",\n      \"options\": [\n        \"a) UML diagrams\",\n        \"b) Structured design languages\",\n        \"c) Mathematical specifications\",\n        \"d) Numbered sentences in natural language\"\n      ],\n      \"correct_answer\": \"d) Numbered sentences in natural language\"\n    },\n    {\n      \"question\": \"In the context of Use Case diagrams, what does the 'include' relationship represent?\",\n      \"options\": [\n        \"a) Common behavior shared among multiple use cases\",\n        \"b) Alternative scenarios that extend the main use case\",\n        \"c) Conditional extensions to the original use case\",\n        \"d) Generalization of actors within the system\"\n      ],\n      \"correct_answer\": \"a) Common behavior shared among multiple use cases\"\n    }\n  ]\n}",
        "input: 13 Software Development KPIs Every Dev \\nTeam Should Track \\n \\nThe ever-growing demand for apps and software has led software \\ndevelopers who excel in Python, SQL, and Java to come into the \\nlimelight. \\nEven the trajectory shows a growth of 21% in software development \\noperations by 2028. \\nBut with great news comes great responsibilities. \\nThe rise in demand simply means you need to upscale your \\ndevelopment process in terms of size and quality. \\nAnd to do this, you need a handful of software development KPIs \\nthat will help you build reliable and profitable software. \\nIn this article, you will learn what software development KPIs are, \\nwhy they are so important for your team, and the most prominent \\nKPIs you need to measure to build remarkable software for \\ncustomers and corporate houses. \\nWhat Are Software Development KPIs? \\nKey Performance Indicators (KPIs) are quantifiable measurements \\nused to gauge the performance of your business towards set goals. \\nIn context to software development, these metrics indicate how well \\nyour development efforts align with the business objectives. \\nIf you're here, you might have the know-how of certain software \\ndevelopment KPIs. But you would be surprised to know how \\nwrongly most businesses use KPIs. \\nFor example, measuring lines of code, time taken to code, and the \\nnumber of deploys are not uncommon between businesses. \\nAnd to be honest, these KPIs are nothing but plainly misleading. \\nSuch indicators do not align perfectly with your business objectives. \\nSoftware development KPIs must be much more nuanced to \\nmeasure development projects' success effectively. \\nMoving forward, we have enlisted the 13 best software development \\nKPIs you must track to stay on top of your projects. But before \\ndiving into the matter, let us ask you what makes these KPIs \\nimportant to measure. \\nIs it the agility, flexibility, or management that makes software \\ndevelopment KPIs the right blend of business interest and software \\nquality? \\nBenefits of Choosing the Right Software Development KPIs \\nQuality performance requires constant monitoring. Besides, there's \\nnothing wrong with tracking everything that goes along with your \\ndevelopment operations. \\nFor example, estimating the time taken for software development is \\nan excellent KPI to measure. You may ask why? \\nThe insights generated via this metric will help you: \\n Optimize the time spent on the development process \\n Plan your tasks and goals accordingly \\nLikewise, other software development KPIs serve a purpose – \\ndetecting errors, solving problems, or helping in decision-making. \\nKeeping it short, these KPIs allow you to: \\n Monitor the company's health \\n Gauge progresses against goals and objectives \\n Analyze and iterate development patterns over time \\n Solve problems and grab opportunities via predictive data \\n13 Best Software KPIs Every Development Manager \\nMust Track \\nKPI #1. Cycle Time \\nCycle time is among the DevOps Research and Assessment team \\n(DORA) metrics. DevOps teams widely use DORA metrics to \\nmeasure their performance and determine whether they are \\\"low \\nperformers\\\" or \\\"elite performers.\\\" \\nCycle time measures the time spent by the dev team members \\nto complete a specific task. \\nDevelopment teams use this KPI to measure the team's productivity \\nand analyze the development process's efficiency. \\nWhy Is It Important? \\nCycle time matters because the lower it is, the surplus code your \\nteam is shipping. Plus, measuring this metric can benefit you in two \\nways. \\nFirstly, you get to know how long it takes to complete a task and \\nuse data to objectively quantify your team's performance. You can \\nalso predict the cycle time for future similar development projects. \\nSecondly, you can spot any process blockages, like something \\ncausing inconsistencies or obstruction. \\nHere's a simple formula to calculate cycle time: \\n \\n \\nKPI #2. Development Velocity \\nDevelopment velocity refers to the amount of work your team can \\ncomplete during a sprint. \\nFor those unaware, a sprint is a set period of time during which \\nspecific tasks are to be completed. \\nIt's basically a part of the Scrum methodology used by agile \\ncompanies to manage employee productivity. \\nSo, during sprints, most teams use story points to estimate the \\namount of effort it will take to complete a task. The measure is on a \\nscale of 1 to 10, with 1 being the quickest task and 10 being the \\nmost complicated. \\nWhy Is It Important? \\nDevelopment velocity lets you and your team analyze your efforts \\nand foresee your performance on other recurring tasks. You can also \\ncompare past and current sprint velocities to measure team \\nproductivity. \\nSuppose we say, out of three consecutive sprints, your velocity \\nstood at 100,120, and 140, respectively. This data can help you \\nunderstand three important things: \\n Workload your team can handle \\n Increase in productivity over sprints \\n Average time taken to complete projects \\nDevelopment velocity also conveys a lot about how realistic your \\nbusiness goals are. \\n \\n \\nHere's a quick formula to measure this software KPI: \\n \\n \\nKPI #3. Change Failure Rate \\nThe change failure rate (CFR)  is an extremely useful metric for \\nmeasuring quality. It’s the percentage of deployments that cause a \\nfailure in production. \\nWhy Is It Important? \\nCode quality is subjective in nature, making it hard to measure and \\nanalyze. But however complex its measurement is, it's an important \\nmetric to track. \\nThe change failure rate is a handy metric that development teams \\nuse to test the quality of source codes. \\nA lower CFR means that your code has fewer bugs and is of higher \\nquality. In contrast, a higher CFR means the other way around. \\nA higher CFR also means that your dev team must again put in the \\ntime, resources, and brain to revamp the code and make it error-\\nfree. Doing this complicates the overall development process and \\nadds blockage to the free flow of tasks and operations. \\nHere's a straightforward formula to calculate CFR: \\n \\n \\nKPI #4. Deployment Frequency \\nDeployment frequency is among the four DORA metrics and, \\ncomprehensively, a core Agile delivery metric. \\nThis metric refers to the pace at which your development team \\ndeploys code into staging, testing, or production departments. \\nWhy Is It Important? \\nDeployment Frequency is an essential metric to measure because it \\ndirectly aligns with the objective of Agile software delivery, i.e., fast \\nand continuous code delivery. \\nMoreover, as we said, this is a comprehensive metric; it's interlinked \\nwith a few other DORA metrics such as cycle time, change failure \\nrate, mean time to recover, and more. \\nFor example, if DevOps requires 1000 lines of code, is it better to \\ndeploy the whole code at once or segment it into fractions or \\nbatches, like 5 batches of 200 lines of code? \\nThe best way to accomplish the goal would be to deploy 5 batches \\nof code. \\nYou may ask why? \\nSmall fractions of code, say 200 lines, would take less time to be \\ndeployed. Plus, by doing this, you reduce cycle time and allow your \\nproduction team to get started without waiting for the whole code \\nat once. \\nBesides, since the deployments are small, you're entirely in control \\nof them. Even if a code breaks or malfunctions, you know precisely \\nwhich chunk to look upon. \\nFor the most part, this metric is essential for: \\n Organizations looking to increase their agile development \\nmaturity \\n Organizations with a history of infrequent or deployed \\ndeployments \\n \\nKPI #5. Pull Request [PR] Size \\nA pull request, also known as a merge request, is when a developer \\nbegins the process of merging new code changes with the main \\nproject after reviewing them. \\nPR size is the number of pull requests reviewed and merged with \\nthe ongoing project trajectory over a period. \\nWhy Is It Important? \\nPull request is a way for developers to tell that they are done with \\nwriting the code and that it is ready to be reviewed and merged. \\nHowever, an ideal pull request might take up to 4 days. Hence, an \\nincrease in PR size accounts for the delay in cycle time. \\nYou must ensure that your PR size stays low to get things going \\nsmoothly. You can do that by reviewing certain chunks of code in \\nregular intervals instead of waiting for the right moment (which, \\nphilosophically, never comes). \\nTypically, a PR size of less than 250 code changes is considered to \\nbe elite by DevOps. \\nKPI #6. Defect Detection Ratio [DDR] \\nWe believe in the supremacy of technology, but we also believe that \\nevery technical product faces defects. It can be detected during the \\ntesting phase, or it might slip to your end user. \\nThe defect detection ratio, also calculated as a percentage, is the \\nratio of defects found prior to release vs. the number of defects \\nfound post-release. \\n \\nWhy Is It Important? \\nThe DDR helps you gauge the effectiveness of your testing team. \\nFor example, you can track the percentage of defects that surpass \\nyour development and testing phase and land with your customers. \\nEventually, this indicates poor user experience, hampering your \\noverall software quality and integrity. \\nMoreover, by measuring this software KPI, you can: \\n Measure the effectiveness of the process adopted for testing \\n Expose the weakest link in the process, and take corrective \\nmeasures \\n Evaluate the performance of the testing team \\nIn general, a higher DDR indicates the impressive performance of \\nyour testing team and vice versa. \\nHere's how you can calculate defect detection percentage: \\n \\nHere, \\nA is the number of defects at the moment of software version \\nrelease \\nB is the number of defects that escaped testing and are detected by \\nend-users \\nSuppose a case where 100 defects were detected in the testing \\nphase and 20 defects were found by customers after release. Here, \\nthe defect detection percentage will be: \\n[100 / (100+20)] X 100 = 83.33. \\nYour DDP stands at 83.33%. \\nKPI #7. Code Coverage Percentage \\nCode coverage percentage is yet another essential metric for \\nDevOps. \\nThe CCP is used to measure the quality of code deployed for testing \\nor production purposes. \\nAlso known as test coverage, this metric determines how your \\nsource code executes when tested. \\nWhy Is It Important? \\nThe CCP allows software development managers to identify the \\nquality of code. The metric mainly shows how many code lines are \\nsuccessfully executed and how many of them need compilation or \\noptimization. \\nThe higher the CCP, the more reliable and efficient your code is, and \\nvice versa. \\nNote: Coding, being a next-level language for humans, often \\naccounts for some human errors. Therefore, one shouldn't aim for a \\n100% CCP; the more, the better. \\n \\nA lower CCP indicates that the source code provided is often \\nencountering bugs and errors during testing. You can use this data \\nto improve and raise the bar of your team's coding unit. \\n \\nKPI #8. Code Churn \\nCode churn, often termed code stability, is the measure of the \\nnumber of times code changes or requires iterations over a period. \\nWhy Is It Important? \\nCode stability is a lethargic yet essential metric to measure. \\nIt's used during DevOps to measure the number of times a code is \\nbeing rewritten or iterated due to introducing a new feature or \\nupgraded software version. \\nWhile code churn isn't something bad or unusual, a higher code \\nchurn often results in high maintenance and thus caters to high risk. \\nAn experiment by GitPrime's data science team found that the \\naverage code churn levels run between 13-30% (70-87% code \\nefficiency). \\n \\n \\nSource \\nHowever, DevOps can comfortably operate at 25% code churn, \\nwhich depicts 75% efficiency of the code. \\nHere's a simple formula to calculate the code churn rate: \\n \\n \\nKPI #9. Code Simplicity \\nA simple code executed successfully is of more value than a \\ncomplex code which requires rigorous testing and iterations. \\nCode simplicity, as the name suggests, measures the number of \\nindependent paths your code has. \\nWhy Is It Important? \\nUndoubtedly, simpler code is easier to test and maintain for your \\ntesting team. It reduces the overall time consumed in testing and \\niterating the code for perfection. \\nUnderstand it like this: the fewer independent paths your code has, \\nthe higher the code's simplicity and the less time it takes for \\nsupport, review, testing, and debugging. \\nKPI #10. Cumulative Flow \\nSoftware development processes are complicated as hell. They have \\na cluster of “Ongoing\\\" and \\\"To be Done\\\" tasks that need to be \\nstreamlined. \\nCumulative Flow demonstrates the status quo of your software tasks \\nor tickets via visual diagrams. \\nGenerally represented as a table, cumulative flow uses different \\ncolors to represent different stages like 'Approved,' 'In Progress,' \\n'Backlog,' and more. \\nMoreover, these colors are arranged in bands so that the width of \\nthe band correlates to cycle time. \\nWhy Is It Important? \\nCumulative flow revolves around three essential engineering metrics \\nof the workflow: Throughput, cycle time, and work in progress. \\nThereby allowing teams to identify bottlenecks and work towards \\nstability of the workflow. Cumulative flow becomes important when \\ndealing with long-term or complex processes requiring a \\nstreamlined development process and effective collaboration \\nbetween departments. \\nKPI #11. Bug Rates \\nBug rates refer to the frequency of bugs being discovered during \\ntesting. \\nSimply put, it is the process of logging and monitoring the bugs or \\nerrors encountered during software testing. \\nWhy Is It Important? \\nAccording to a National Institute of Standard Technology study, \\nsoftware bugs cost the U.S economy $59.9 billion annually. That \\nmakes it pretty clear why it's an important metric to measure. \\nThis metric is similar to the defect rate but not essentially common \\nto that. \\nMajorly, bugs are measured from two aspects: the total number of \\nbugs and the severity of the bugs. \\nWhile you can always count the number of bugs and fix the \\nmaximum number, the severity of bugs should remain minimum. \\nHere's a simple formula to measure bug rate: \\n \\n \\nIf the bug rate is more than the acceptable benchmark or the \\nseverity of the bugs is higher than the medium level, it's time to \\nmake adjustments to your code. \\nKPI #12. Mean Time Between Failures [MTBF] and Mean Time to Repair \\n[MTTR] \\nMean Time Between Failures (MTBF) and Mean Time To Repair \\n(MTTR) are two distinct metrics used to gauge a unified objective - \\nthe reliability of your software. \\nMTBF measures the average time between two failures in the \\nsoftware, and MTTR is simply the time it takes to repair those faults. \\nWhy Is It Important? \\nFailures are part of software development; even professionals bow \\ndown to them. So, it's evident that you can't develop a software \\nwithout tasting failures. \\nBut you can minimize the damage caused by those failures by \\nproactively measuring the number of occurring failures and \\noptimizing the time it takes to repair those faults. \\nHere's how you can calculate MTBF and MTTR: \\n \\n \\nPro Tip: Calculating the metrics simultaneously can help you \\nmeasure your software development teams' overall productivity and \\nefficiency. \\n \\n \\nKPI #13. Net Promoter Score \\nThe end users of every software are customers, be it B2C or B2B. \\nAnd what matters most is the customer satisfaction \\nNet Promoter Score (NPS) is a widely used metric that measures the \\nlevel of satisfaction users get after using your product or service. \\nThrough NPS, you get a score between 0 to 10, where 0 reflects the \\nworst experience of your software, while a rating above 8 resonates \\nwith an excellent user experience. \\nTo ease the measurement process, the people who vote between 0 \\nto 4 are termed Detractors, 5 to 6 are termed neutral, and above 6 \\nare known as promoters. \\nWhy Is It Important? \\nIf the number of promoters exceeds the number of detractors, your \\nsoftware is performing impressively well. And if it's the other way, \\nyou need to make changes in the final software to make it better for \\nusers. \\nHere's a simple formula to calculate NPS: \\n \\n \\nPro Tip: Before launching your software to the market, share an \\nNPS from within your organization and ask employees and \\nexecutives to test the software on their own and give feedback via \\nNPS. \\nGenerate a hard short answer question with its answer",
        "output: {\n  \"questions\": [\n    {\n      \"question\": \"What are the benefits of choosing the right software development KPIs?\",\n      \"answer\": \"Monitoring Company Health: KPIs allow for monitoring the overall health of the company's software development operations.\\nGauging Progress: They help in measuring progress against goals and objectives set for development projects.\\nAnalyzing and Iterating: KPIs enable analysis and iteration of development patterns over time, leading to continuous improvement.\\nProblem Solving and Opportunity Grasping: By providing predictive data, KPIs help in identifying problems and seizing opportunities for improvement.\"\n    }\n  ]\n}",
        "input: input: 13 Software Development KPIs Every Dev \\nTeam Should Track \\n \\nThe ever-growing demand for apps and software has led software \\ndevelopers who excel in Python, SQL, and Java to come into the \\nlimelight. \\nEven the trajectory shows a growth of 21% in software development \\noperations by 2028. \\nBut with great news comes great responsibilities. \\nThe rise in demand simply means you need to upscale your \\ndevelopment process in terms of size and quality. \\nAnd to do this, you need a handful of software development KPIs \\nthat will help you build reliable and profitable software. \\nIn this article, you will learn what software development KPIs are, \\nwhy they are so important for your team, and the most prominent \\nKPIs you need to measure to build remarkable software for \\ncustomers and corporate houses. \\nWhat Are Software Development KPIs? \\nKey Performance Indicators (KPIs) are quantifiable measurements \\nused to gauge the performance of your business towards set goals. \\nIn context to software development, these metrics indicate how well \\nyour development efforts align with the business objectives. \\nIf you're here, you might have the know-how of certain software \\ndevelopment KPIs. But you would be surprised to know how \\nwrongly most businesses use KPIs. \\nFor example, measuring lines of code, time taken to code, and the \\nnumber of deploys are not uncommon between businesses. \\nAnd to be honest, these KPIs are nothing but plainly misleading. \\nSuch indicators do not align perfectly with your business objectives. \\nSoftware development KPIs must be much more nuanced to \\nmeasure development projects' success effectively. \\nMoving forward, we have enlisted the 13 best software development \\nKPIs you must track to stay on top of your projects. But before \\ndiving into the matter, let us ask you what makes these KPIs \\nimportant to measure. \\nIs it the agility, flexibility, or management that makes software \\ndevelopment KPIs the right blend of business interest and software \\nquality? \\nBenefits of Choosing the Right Software Development KPIs \\nQuality performance requires constant monitoring. Besides, there's \\nnothing wrong with tracking everything that goes along with your \\ndevelopment operations. \\nFor example, estimating the time taken for software development is \\nan excellent KPI to measure. You may ask why? \\nThe insights generated via this metric will help you: \\n Optimize the time spent on the development process \\n Plan your tasks and goals accordingly \\nLikewise, other software development KPIs serve a purpose – \\ndetecting errors, solving problems, or helping in decision-making. \\nKeeping it short, these KPIs allow you to: \\n Monitor the company's health \\n Gauge progresses against goals and objectives \\n Analyze and iterate development patterns over time \\n Solve problems and grab opportunities via predictive data \\n13 Best Software KPIs Every Development Manager \\nMust Track \\nKPI #1. Cycle Time \\nCycle time is among the DevOps Research and Assessment team \\n(DORA) metrics. DevOps teams widely use DORA metrics to \\nmeasure their performance and determine whether they are \\\"low \\nperformers\\\" or \\\"elite performers.\\\" \\nCycle time measures the time spent by the dev team members \\nto complete a specific task. \\nDevelopment teams use this KPI to measure the team's productivity \\nand analyze the development process's efficiency. \\nWhy Is It Important? \\nCycle time matters because the lower it is, the surplus code your \\nteam is shipping. Plus, measuring this metric can benefit you in two \\nways. \\nFirstly, you get to know how long it takes to complete a task and \\nuse data to objectively quantify your team's performance. You can \\nalso predict the cycle time for future similar development projects. \\nSecondly, you can spot any process blockages, like something \\ncausing inconsistencies or obstruction. \\nHere's a simple formula to calculate cycle time: \\n \\n \\nKPI #2. Development Velocity \\nDevelopment velocity refers to the amount of work your team can \\ncomplete during a sprint. \\nFor those unaware, a sprint is a set period of time during which \\nspecific tasks are to be completed. \\nIt's basically a part of the Scrum methodology used by agile \\ncompanies to manage employee productivity. \\nSo, during sprints, most teams use story points to estimate the \\namount of effort it will take to complete a task. The measure is on a \\nscale of 1 to 10, with 1 being the quickest task and 10 being the \\nmost complicated. \\nWhy Is It Important? \\nDevelopment velocity lets you and your team analyze your efforts \\nand foresee your performance on other recurring tasks. You can also \\ncompare past and current sprint velocities to measure team \\nproductivity. \\nSuppose we say, out of three consecutive sprints, your velocity \\nstood at 100,120, and 140, respectively. This data can help you \\nunderstand three important things: \\n Workload your team can handle \\n Increase in productivity over sprints \\n Average time taken to complete projects \\nDevelopment velocity also conveys a lot about how realistic your \\nbusiness goals are. \\n \\n \\nHere's a quick formula to measure this software KPI: \\n \\n \\nKPI #3. Change Failure Rate \\nThe change failure rate (CFR)  is an extremely useful metric for \\nmeasuring quality. It’s the percentage of deployments that cause a \\nfailure in production. \\nWhy Is It Important? \\nCode quality is subjective in nature, making it hard to measure and \\nanalyze. But however complex its measurement is, it's an important \\nmetric to track. \\nThe change failure rate is a handy metric that development teams \\nuse to test the quality of source codes. \\nA lower CFR means that your code has fewer bugs and is of higher \\nquality. In contrast, a higher CFR means the other way around. \\nA higher CFR also means that your dev team must again put in the \\ntime, resources, and brain to revamp the code and make it error-\\nfree. Doing this complicates the overall development process and \\nadds blockage to the free flow of tasks and operations. \\nHere's a straightforward formula to calculate CFR: \\n \\n \\nKPI #4. Deployment Frequency \\nDeployment frequency is among the four DORA metrics and, \\ncomprehensively, a core Agile delivery metric. \\nThis metric refers to the pace at which your development team \\ndeploys code into staging, testing, or production departments. \\nWhy Is It Important? \\nDeployment Frequency is an essential metric to measure because it \\ndirectly aligns with the objective of Agile software delivery, i.e., fast \\nand continuous code delivery. \\nMoreover, as we said, this is a comprehensive metric; it's interlinked \\nwith a few other DORA metrics such as cycle time, change failure \\nrate, mean time to recover, and more. \\nFor example, if DevOps requires 1000 lines of code, is it better to \\ndeploy the whole code at once or segment it into fractions or \\nbatches, like 5 batches of 200 lines of code? \\nThe best way to accomplish the goal would be to deploy 5 batches \\nof code. \\nYou may ask why? \\nSmall fractions of code, say 200 lines, would take less time to be \\ndeployed. Plus, by doing this, you reduce cycle time and allow your \\nproduction team to get started without waiting for the whole code \\nat once. \\nBesides, since the deployments are small, you're entirely in control \\nof them. Even if a code breaks or malfunctions, you know precisely \\nwhich chunk to look upon. \\nFor the most part, this metric is essential for: \\n Organizations looking to increase their agile development \\nmaturity \\n Organizations with a history of infrequent or deployed \\ndeployments \\n \\nKPI #5. Pull Request [PR] Size \\nA pull request, also known as a merge request, is when a developer \\nbegins the process of merging new code changes with the main \\nproject after reviewing them. \\nPR size is the number of pull requests reviewed and merged with \\nthe ongoing project trajectory over a period. \\nWhy Is It Important? \\nPull request is a way for developers to tell that they are done with \\nwriting the code and that it is ready to be reviewed and merged. \\nHowever, an ideal pull request might take up to 4 days. Hence, an \\nincrease in PR size accounts for the delay in cycle time. \\nYou must ensure that your PR size stays low to get things going \\nsmoothly. You can do that by reviewing certain chunks of code in \\nregular intervals instead of waiting for the right moment (which, \\nphilosophically, never comes). \\nTypically, a PR size of less than 250 code changes is considered to \\nbe elite by DevOps. \\nKPI #6. Defect Detection Ratio [DDR] \\nWe believe in the supremacy of technology, but we also believe that \\nevery technical product faces defects. It can be detected during the \\ntesting phase, or it might slip to your end user. \\nThe defect detection ratio, also calculated as a percentage, is the \\nratio of defects found prior to release vs. the number of defects \\nfound post-release. \\n \\nWhy Is It Important? \\nThe DDR helps you gauge the effectiveness of your testing team. \\nFor example, you can track the percentage of defects that surpass \\nyour development and testing phase and land with your customers. \\nEventually, this indicates poor user experience, hampering your \\noverall software quality and integrity. \\nMoreover, by measuring this software KPI, you can: \\n Measure the effectiveness of the process adopted for testing \\n Expose the weakest link in the process, and take corrective \\nmeasures \\n Evaluate the performance of the testing team \\nIn general, a higher DDR indicates the impressive performance of \\nyour testing team and vice versa. \\nHere's how you can calculate defect detection percentage: \\n \\nHere, \\nA is the number of defects at the moment of software version \\nrelease \\nB is the number of defects that escaped testing and are detected by \\nend-users \\nSuppose a case where 100 defects were detected in the testing \\nphase and 20 defects were found by customers after release. Here, \\nthe defect detection percentage will be: \\n[100 / (100+20)] X 100 = 83.33. \\nYour DDP stands at 83.33%. \\nKPI #7. Code Coverage Percentage \\nCode coverage percentage is yet another essential metric for \\nDevOps. \\nThe CCP is used to measure the quality of code deployed for testing \\nor production purposes. \\nAlso known as test coverage, this metric determines how your \\nsource code executes when tested. \\nWhy Is It Important? \\nThe CCP allows software development managers to identify the \\nquality of code. The metric mainly shows how many code lines are \\nsuccessfully executed and how many of them need compilation or \\noptimization. \\nThe higher the CCP, the more reliable and efficient your code is, and \\nvice versa. \\nNote: Coding, being a next-level language for humans, often \\naccounts for some human errors. Therefore, one shouldn't aim for a \\n100% CCP; the more, the better. \\n \\nA lower CCP indicates that the source code provided is often \\nencountering bugs and errors during testing. You can use this data \\nto improve and raise the bar of your team's coding unit. \\n \\nKPI #8. Code Churn \\nCode churn, often termed code stability, is the measure of the \\nnumber of times code changes or requires iterations over a period. \\nWhy Is It Important? \\nCode stability is a lethargic yet essential metric to measure. \\nIt's used during DevOps to measure the number of times a code is \\nbeing rewritten or iterated due to introducing a new feature or \\nupgraded software version. \\nWhile code churn isn't something bad or unusual, a higher code \\nchurn often results in high maintenance and thus caters to high risk. \\nAn experiment by GitPrime's data science team found that the \\naverage code churn levels run between 13-30% (70-87% code \\nefficiency). \\n \\n \\nSource \\nHowever, DevOps can comfortably operate at 25% code churn, \\nwhich depicts 75% efficiency of the code. \\nHere's a simple formula to calculate the code churn rate: \\n \\n \\nKPI #9. Code Simplicity \\nA simple code executed successfully is of more value than a \\ncomplex code which requires rigorous testing and iterations. \\nCode simplicity, as the name suggests, measures the number of \\nindependent paths your code has. \\nWhy Is It Important? \\nUndoubtedly, simpler code is easier to test and maintain for your \\ntesting team. It reduces the overall time consumed in testing and \\niterating the code for perfection. \\nUnderstand it like this: the fewer independent paths your code has, \\nthe higher the code's simplicity and the less time it takes for \\nsupport, review, testing, and debugging. \\nKPI #10. Cumulative Flow \\nSoftware development processes are complicated as hell. They have \\na cluster of “Ongoing\\\" and \\\"To be Done\\\" tasks that need to be \\nstreamlined. \\nCumulative Flow demonstrates the status quo of your software tasks \\nor tickets via visual diagrams. \\nGenerally represented as a table, cumulative flow uses different \\ncolors to represent different stages like 'Approved,' 'In Progress,' \\n'Backlog,' and more. \\nMoreover, these colors are arranged in bands so that the width of \\nthe band correlates to cycle time. \\nWhy Is It Important? \\nCumulative flow revolves around three essential engineering metrics \\nof the workflow: Throughput, cycle time, and work in progress. \\nThereby allowing teams to identify bottlenecks and work towards \\nstability of the workflow. Cumulative flow becomes important when \\ndealing with long-term or complex processes requiring a \\nstreamlined development process and effective collaboration \\nbetween departments. \\nKPI #11. Bug Rates \\nBug rates refer to the frequency of bugs being discovered during \\ntesting. \\nSimply put, it is the process of logging and monitoring the bugs or \\nerrors encountered during software testing. \\nWhy Is It Important? \\nAccording to a National Institute of Standard Technology study, \\nsoftware bugs cost the U.S economy $59.9 billion annually. That \\nmakes it pretty clear why it's an important metric to measure. \\nThis metric is similar to the defect rate but not essentially common \\nto that. \\nMajorly, bugs are measured from two aspects: the total number of \\nbugs and the severity of the bugs. \\nWhile you can always count the number of bugs and fix the \\nmaximum number, the severity of bugs should remain minimum. \\nHere's a simple formula to measure bug rate: \\n \\n \\nIf the bug rate is more than the acceptable benchmark or the \\nseverity of the bugs is higher than the medium level, it's time to \\nmake adjustments to your code. \\nKPI #12. Mean Time Between Failures [MTBF] and Mean Time to Repair \\n[MTTR] \\nMean Time Between Failures (MTBF) and Mean Time To Repair \\n(MTTR) are two distinct metrics used to gauge a unified objective - \\nthe reliability of your software. \\nMTBF measures the average time between two failures in the \\nsoftware, and MTTR is simply the time it takes to repair those faults. \\nWhy Is It Important? \\nFailures are part of software development; even professionals bow \\ndown to them. So, it's evident that you can't develop a software \\nwithout tasting failures. \\nBut you can minimize the damage caused by those failures by \\nproactively measuring the number of occurring failures and \\noptimizing the time it takes to repair those faults. \\nHere's how you can calculate MTBF and MTTR: \\n \\n \\nPro Tip: Calculating the metrics simultaneously can help you \\nmeasure your software development teams' overall productivity and \\nefficiency. \\n \\n \\nKPI #13. Net Promoter Score \\nThe end users of every software are customers, be it B2C or B2B. \\nAnd what matters most is the customer satisfaction \\nNet Promoter Score (NPS) is a widely used metric that measures the \\nlevel of satisfaction users get after using your product or service. \\nThrough NPS, you get a score between 0 to 10, where 0 reflects the \\nworst experience of your software, while a rating above 8 resonates \\nwith an excellent user experience. \\nTo ease the measurement process, the people who vote between 0 \\nto 4 are termed Detractors, 5 to 6 are termed neutral, and above 6 \\nare known as promoters. \\nWhy Is It Important? \\nIf the number of promoters exceeds the number of detractors, your \\nsoftware is performing impressively well. And if it's the other way, \\nyou need to make changes in the final software to make it better for \\nusers. \\nHere's a simple formula to calculate NPS: \\n \\n \\nPro Tip: Before launching your software to the market, share an \\nNPS from within your organization and ask employees and \\nexecutives to test the software on their own and give feedback via \\nNPS. \\nGenerate 2 medium multiple choice question with four answers and one answer only is correct",
        "output: {\n  \"questions\": [\n    {\n      \"question\": \"What does Cycle Time measure in software development?\",\n      \"options\": [\n        \"A) Number of lines of code written per hour\",\n        \"B) Time taken to complete a specific task\",\n        \"C) Number of deployments per sprint\",\n        \"D) Number of bugs found in testing\"\n      ],\n      \"correct_answer\": \"B) Time taken to complete a specific task\"\n    },\n    {\n      \"question\": \"What is the purpose of Deployment Frequency as a software development KPI?\",\n      \"options\": [\n        \"A) To measure the number of lines of code deployed per hour\",\n        \"B) To track the number of deployments without considering their impact\",\n        \"C) To ensure all code changes are deployed simultaneously\",\n        \"D) To support fast and continuous code delivery\"\n      ],\n      \"correct_answer\": \"D) To support fast and continuous code delivery\"\n    }\n  ]\n}",
        "input: input: 13 Software Development KPIs Every Dev \\nTeam Should Track \\n \\nThe ever-growing demand for apps and software has led software \\ndevelopers who excel in Python, SQL, and Java to come into the \\nlimelight. \\nEven the trajectory shows a growth of 21% in software development \\noperations by 2028. \\nBut with great news comes great responsibilities. \\nThe rise in demand simply means you need to upscale your \\ndevelopment process in terms of size and quality. \\nAnd to do this, you need a handful of software development KPIs \\nthat will help you build reliable and profitable software. \\nIn this article, you will learn what software development KPIs are, \\nwhy they are so important for your team, and the most prominent \\nKPIs you need to measure to build remarkable software for \\ncustomers and corporate houses. \\nWhat Are Software Development KPIs? \\nKey Performance Indicators (KPIs) are quantifiable measurements \\nused to gauge the performance of your business towards set goals. \\nIn context to software development, these metrics indicate how well \\nyour development efforts align with the business objectives. \\nIf you're here, you might have the know-how of certain software \\ndevelopment KPIs. But you would be surprised to know how \\nwrongly most businesses use KPIs. \\nFor example, measuring lines of code, time taken to code, and the \\nnumber of deploys are not uncommon between businesses. \\nAnd to be honest, these KPIs are nothing but plainly misleading. \\nSuch indicators do not align perfectly with your business objectives. \\nSoftware development KPIs must be much more nuanced to \\nmeasure development projects' success effectively. \\nMoving forward, we have enlisted the 13 best software development \\nKPIs you must track to stay on top of your projects. But before \\ndiving into the matter, let us ask you what makes these KPIs \\nimportant to measure. \\nIs it the agility, flexibility, or management that makes software \\ndevelopment KPIs the right blend of business interest and software \\nquality? \\nBenefits of Choosing the Right Software Development KPIs \\nQuality performance requires constant monitoring. Besides, there's \\nnothing wrong with tracking everything that goes along with your \\ndevelopment operations. \\nFor example, estimating the time taken for software development is \\nan excellent KPI to measure. You may ask why? \\nThe insights generated via this metric will help you: \\n Optimize the time spent on the development process \\n Plan your tasks and goals accordingly \\nLikewise, other software development KPIs serve a purpose – \\ndetecting errors, solving problems, or helping in decision-making. \\nKeeping it short, these KPIs allow you to: \\n Monitor the company's health \\n Gauge progresses against goals and objectives \\n Analyze and iterate development patterns over time \\n Solve problems and grab opportunities via predictive data \\n13 Best Software KPIs Every Development Manager \\nMust Track \\nKPI #1. Cycle Time \\nCycle time is among the DevOps Research and Assessment team \\n(DORA) metrics. DevOps teams widely use DORA metrics to \\nmeasure their performance and determine whether they are \\\"low \\nperformers\\\" or \\\"elite performers.\\\" \\nCycle time measures the time spent by the dev team members \\nto complete a specific task. \\nDevelopment teams use this KPI to measure the team's productivity \\nand analyze the development process's efficiency. \\nWhy Is It Important? \\nCycle time matters because the lower it is, the surplus code your \\nteam is shipping. Plus, measuring this metric can benefit you in two \\nways. \\nFirstly, you get to know how long it takes to complete a task and \\nuse data to objectively quantify your team's performance. You can \\nalso predict the cycle time for future similar development projects. \\nSecondly, you can spot any process blockages, like something \\ncausing inconsistencies or obstruction. \\nHere's a simple formula to calculate cycle time: \\n \\n \\nKPI #2. Development Velocity \\nDevelopment velocity refers to the amount of work your team can \\ncomplete during a sprint. \\nFor those unaware, a sprint is a set period of time during which \\nspecific tasks are to be completed. \\nIt's basically a part of the Scrum methodology used by agile \\ncompanies to manage employee productivity. \\nSo, during sprints, most teams use story points to estimate the \\namount of effort it will take to complete a task. The measure is on a \\nscale of 1 to 10, with 1 being the quickest task and 10 being the \\nmost complicated. \\nWhy Is It Important? \\nDevelopment velocity lets you and your team analyze your efforts \\nand foresee your performance on other recurring tasks. You can also \\ncompare past and current sprint velocities to measure team \\nproductivity. \\nSuppose we say, out of three consecutive sprints, your velocity \\nstood at 100,120, and 140, respectively. This data can help you \\nunderstand three important things: \\n Workload your team can handle \\n Increase in productivity over sprints \\n Average time taken to complete projects \\nDevelopment velocity also conveys a lot about how realistic your \\nbusiness goals are. \\n \\n \\nHere's a quick formula to measure this software KPI: \\n \\n \\nKPI #3. Change Failure Rate \\nThe change failure rate (CFR)  is an extremely useful metric for \\nmeasuring quality. It’s the percentage of deployments that cause a \\nfailure in production. \\nWhy Is It Important? \\nCode quality is subjective in nature, making it hard to measure and \\nanalyze. But however complex its measurement is, it's an important \\nmetric to track. \\nThe change failure rate is a handy metric that development teams \\nuse to test the quality of source codes. \\nA lower CFR means that your code has fewer bugs and is of higher \\nquality. In contrast, a higher CFR means the other way around. \\nA higher CFR also means that your dev team must again put in the \\ntime, resources, and brain to revamp the code and make it error-\\nfree. Doing this complicates the overall development process and \\nadds blockage to the free flow of tasks and operations. \\nHere's a straightforward formula to calculate CFR: \\n \\n \\nKPI #4. Deployment Frequency \\nDeployment frequency is among the four DORA metrics and, \\ncomprehensively, a core Agile delivery metric. \\nThis metric refers to the pace at which your development team \\ndeploys code into staging, testing, or production departments. \\nWhy Is It Important? \\nDeployment Frequency is an essential metric to measure because it \\ndirectly aligns with the objective of Agile software delivery, i.e., fast \\nand continuous code delivery. \\nMoreover, as we said, this is a comprehensive metric; it's interlinked \\nwith a few other DORA metrics such as cycle time, change failure \\nrate, mean time to recover, and more. \\nFor example, if DevOps requires 1000 lines of code, is it better to \\ndeploy the whole code at once or segment it into fractions or \\nbatches, like 5 batches of 200 lines of code? \\nThe best way to accomplish the goal would be to deploy 5 batches \\nof code. \\nYou may ask why? \\nSmall fractions of code, say 200 lines, would take less time to be \\ndeployed. Plus, by doing this, you reduce cycle time and allow your \\nproduction team to get started without waiting for the whole code \\nat once. \\nBesides, since the deployments are small, you're entirely in control \\nof them. Even if a code breaks or malfunctions, you know precisely \\nwhich chunk to look upon. \\nFor the most part, this metric is essential for: \\n Organizations looking to increase their agile development \\nmaturity \\n Organizations with a history of infrequent or deployed \\ndeployments \\n \\nKPI #5. Pull Request [PR] Size \\nA pull request, also known as a merge request, is when a developer \\nbegins the process of merging new code changes with the main \\nproject after reviewing them. \\nPR size is the number of pull requests reviewed and merged with \\nthe ongoing project trajectory over a period. \\nWhy Is It Important? \\nPull request is a way for developers to tell that they are done with \\nwriting the code and that it is ready to be reviewed and merged. \\nHowever, an ideal pull request might take up to 4 days. Hence, an \\nincrease in PR size accounts for the delay in cycle time. \\nYou must ensure that your PR size stays low to get things going \\nsmoothly. You can do that by reviewing certain chunks of code in \\nregular intervals instead of waiting for the right moment (which, \\nphilosophically, never comes). \\nTypically, a PR size of less than 250 code changes is considered to \\nbe elite by DevOps. \\nKPI #6. Defect Detection Ratio [DDR] \\nWe believe in the supremacy of technology, but we also believe that \\nevery technical product faces defects. It can be detected during the \\ntesting phase, or it might slip to your end user. \\nThe defect detection ratio, also calculated as a percentage, is the \\nratio of defects found prior to release vs. the number of defects \\nfound post-release. \\n \\nWhy Is It Important? \\nThe DDR helps you gauge the effectiveness of your testing team. \\nFor example, you can track the percentage of defects that surpass \\nyour development and testing phase and land with your customers. \\nEventually, this indicates poor user experience, hampering your \\noverall software quality and integrity. \\nMoreover, by measuring this software KPI, you can: \\n Measure the effectiveness of the process adopted for testing \\n Expose the weakest link in the process, and take corrective \\nmeasures \\n Evaluate the performance of the testing team \\nIn general, a higher DDR indicates the impressive performance of \\nyour testing team and vice versa. \\nHere's how you can calculate defect detection percentage: \\n \\nHere, \\nA is the number of defects at the moment of software version \\nrelease \\nB is the number of defects that escaped testing and are detected by \\nend-users \\nSuppose a case where 100 defects were detected in the testing \\nphase and 20 defects were found by customers after release. Here, \\nthe defect detection percentage will be: \\n[100 / (100+20)] X 100 = 83.33. \\nYour DDP stands at 83.33%. \\nKPI #7. Code Coverage Percentage \\nCode coverage percentage is yet another essential metric for \\nDevOps. \\nThe CCP is used to measure the quality of code deployed for testing \\nor production purposes. \\nAlso known as test coverage, this metric determines how your \\nsource code executes when tested. \\nWhy Is It Important? \\nThe CCP allows software development managers to identify the \\nquality of code. The metric mainly shows how many code lines are \\nsuccessfully executed and how many of them need compilation or \\noptimization. \\nThe higher the CCP, the more reliable and efficient your code is, and \\nvice versa. \\nNote: Coding, being a next-level language for humans, often \\naccounts for some human errors. Therefore, one shouldn't aim for a \\n100% CCP; the more, the better. \\n \\nA lower CCP indicates that the source code provided is often \\nencountering bugs and errors during testing. You can use this data \\nto improve and raise the bar of your team's coding unit. \\n \\nKPI #8. Code Churn \\nCode churn, often termed code stability, is the measure of the \\nnumber of times code changes or requires iterations over a period. \\nWhy Is It Important? \\nCode stability is a lethargic yet essential metric to measure. \\nIt's used during DevOps to measure the number of times a code is \\nbeing rewritten or iterated due to introducing a new feature or \\nupgraded software version. \\nWhile code churn isn't something bad or unusual, a higher code \\nchurn often results in high maintenance and thus caters to high risk. \\nAn experiment by GitPrime's data science team found that the \\naverage code churn levels run between 13-30% (70-87% code \\nefficiency). \\n \\n \\nSource \\nHowever, DevOps can comfortably operate at 25% code churn, \\nwhich depicts 75% efficiency of the code. \\nHere's a simple formula to calculate the code churn rate: \\n \\n \\nKPI #9. Code Simplicity \\nA simple code executed successfully is of more value than a \\ncomplex code which requires rigorous testing and iterations. \\nCode simplicity, as the name suggests, measures the number of \\nindependent paths your code has. \\nWhy Is It Important? \\nUndoubtedly, simpler code is easier to test and maintain for your \\ntesting team. It reduces the overall time consumed in testing and \\niterating the code for perfection. \\nUnderstand it like this: the fewer independent paths your code has, \\nthe higher the code's simplicity and the less time it takes for \\nsupport, review, testing, and debugging. \\nKPI #10. Cumulative Flow \\nSoftware development processes are complicated as hell. They have \\na cluster of “Ongoing\\\" and \\\"To be Done\\\" tasks that need to be \\nstreamlined. \\nCumulative Flow demonstrates the status quo of your software tasks \\nor tickets via visual diagrams. \\nGenerally represented as a table, cumulative flow uses different \\ncolors to represent different stages like 'Approved,' 'In Progress,' \\n'Backlog,' and more. \\nMoreover, these colors are arranged in bands so that the width of \\nthe band correlates to cycle time. \\nWhy Is It Important? \\nCumulative flow revolves around three essential engineering metrics \\nof the workflow: Throughput, cycle time, and work in progress. \\nThereby allowing teams to identify bottlenecks and work towards \\nstability of the workflow. Cumulative flow becomes important when \\ndealing with long-term or complex processes requiring a \\nstreamlined development process and effective collaboration \\nbetween departments. \\nKPI #11. Bug Rates \\nBug rates refer to the frequency of bugs being discovered during \\ntesting. \\nSimply put, it is the process of logging and monitoring the bugs or \\nerrors encountered during software testing. \\nWhy Is It Important? \\nAccording to a National Institute of Standard Technology study, \\nsoftware bugs cost the U.S economy $59.9 billion annually. That \\nmakes it pretty clear why it's an important metric to measure. \\nThis metric is similar to the defect rate but not essentially common \\nto that. \\nMajorly, bugs are measured from two aspects: the total number of \\nbugs and the severity of the bugs. \\nWhile you can always count the number of bugs and fix the \\nmaximum number, the severity of bugs should remain minimum. \\nHere's a simple formula to measure bug rate: \\n \\n \\nIf the bug rate is more than the acceptable benchmark or the \\nseverity of the bugs is higher than the medium level, it's time to \\nmake adjustments to your code. \\nKPI #12. Mean Time Between Failures [MTBF] and Mean Time to Repair \\n[MTTR] \\nMean Time Between Failures (MTBF) and Mean Time To Repair \\n(MTTR) are two distinct metrics used to gauge a unified objective - \\nthe reliability of your software. \\nMTBF measures the average time between two failures in the \\nsoftware, and MTTR is simply the time it takes to repair those faults. \\nWhy Is It Important? \\nFailures are part of software development; even professionals bow \\ndown to them. So, it's evident that you can't develop a software \\nwithout tasting failures. \\nBut you can minimize the damage caused by those failures by \\nproactively measuring the number of occurring failures and \\noptimizing the time it takes to repair those faults. \\nHere's how you can calculate MTBF and MTTR: \\n \\n \\nPro Tip: Calculating the metrics simultaneously can help you \\nmeasure your software development teams' overall productivity and \\nefficiency. \\n \\n \\nKPI #13. Net Promoter Score \\nThe end users of every software are customers, be it B2C or B2B. \\nAnd what matters most is the customer satisfaction \\nNet Promoter Score (NPS) is a widely used metric that measures the \\nlevel of satisfaction users get after using your product or service. \\nThrough NPS, you get a score between 0 to 10, where 0 reflects the \\nworst experience of your software, while a rating above 8 resonates \\nwith an excellent user experience. \\nTo ease the measurement process, the people who vote between 0 \\nto 4 are termed Detractors, 5 to 6 are termed neutral, and above 6 \\nare known as promoters. \\nWhy Is It Important? \\nIf the number of promoters exceeds the number of detractors, your \\nsoftware is performing impressively well. And if it's the other way, \\nyou need to make changes in the final software to make it better for \\nusers. \\nHere's a simple formula to calculate NPS: \\n \\n \\nPro Tip: Before launching your software to the market, share an \\nNPS from within your organization and ask employees and \\nexecutives to test the software on their own and give feedback via \\nNPS. \\nGenerate a multiple choice question with four answers and one answer only is correct",
        "output: {\n  \"questions\": [\n    {\n      \"question\": \"Which of the following is NOT considered a valuable software development KPI?\",\n      \"options\": [\n        \"a) Cycle Time\",\n        \"b) Lines of Code Written\",\n        \"c) Deployment Frequency\",\n        \"d) Change Failure Rate\"\n      ],\n      \"correct_answer\": \"b) Lines of Code Written\"\n    }\n  ]\n}",
        "input: DATA SCİENCE\\nFUNDAMENTALS\\nDr. Diaa Salama\\nLecture Slides for\\nData Science Process?\\n2\\n The methodology Life Cycle to deliver predictive\\nanalytics\\nsolutions\\nand\\nintelligent\\napplications\\nefficiently.\\n helps improve team collaboration and learning by\\nsuggesting how team roles work best together.\\n This Data Science project life cycle\\nand its main\\ncomponents by provide a generic description of the\\nprocess here that can be implemented with different\\nkinds of tools.\\n A more detailed description of the project tasks and\\nroles involved in the lifecycle of the process is provided.\\nData science lifecycle\\n3\\n provides a lifecycle to structure the development of \\nyour data science projects.\\n The lifecycle outlines the major stages that projects \\ntypically execute, often iteratively:\\n1. Business Understanding\\n2. Data Acquisition and Understanding\\n3. Modeling\\n4. Deployment\\nData science lifecycle\\n4\\n1st stage :The business understanding\\n5\\nGoal of The business understanding stage\\n Specify the key variables that are to serve as the \\nmodel targets \\n Identify the relevant data sources (needs to \\nobtain).\\n1st stage :The business understanding\\n6\\n (Objective) There are two main tasks addressed in this \\nstage:\\n Define objectives: Work with your customer and other\\nstakeholders to understand and identify the business\\nproblems.\\nFormulate\\nquestions\\nthat\\ndefine\\nthe\\nbusiness goals that the data science techniques can\\ntarget.\\n Identify data sources: Find the relevant data that \\nhelps you answer the questions that define the \\nobjectives of the project.\\nCont. 1st stage :The business \\nunderstanding (Define objectives)\\n7\\n Define the project goals by asking and refining \\\"sharp\\\" questions\\nthat are relevant, specific, and unambiguous. Data science is a\\nprocess that uses names and numbers to answer such questions. You\\ntypically use data science or machine learning to answer five\\ntypes of questions:\\n1.\\nHow much or how many? (regression)\\n2.\\nWhich category? (classification)\\n3.\\nWhich group? (clustering)\\n4.\\nIs this weird? (anomaly detection)\\n5.\\nWhich option should be taken? (recommendation)\\nDetermine which of these questions you're asking and how answering it\\nachieves your business goals.\\nCont. 1st stage :The business \\nunderstanding (Identify data sources)\\n8\\n Identify\\ndata\\nsources\\nthat\\ncontain\\nknown\\nexamples of answers to your sharp questions.\\n Data that's relevant to the question. \\n you might find that the existing systems need and achieve\\nthe project goals. In this situation, you might want to look\\nfor external data sources or update your systems to\\ncollect new data to collect and log additional kinds of\\ndata to address the problem\\n2nd stage :Data acquisition and understanding\\n9\\nGoals\\n Locate the data set in the fitting analytics \\nenvironment so you are ready to model.\\n Produce a clean, high-quality data set whose \\nrelationship to the target variables is understood.\\n Develop a solution architecture of the data \\npipeline that refreshes and scores the data \\nregularly.\\n2nd stage :Data acquisition and understanding\\n10\\nObjective There are three main tasks addressed in this\\nstage:\\n Ingest the data into the target analytic environment.\\n Explore the data to determine if the data quality is\\nacceptable to answer the question.\\n Set up a data pipeline to score new or regularly\\nrefreshed data.\\n2nd stage :Data acquisition and understanding\\n11\\nIngest the data\\n move the data from the source locations to the target locations\\nwhere you run analytics operations, like training and predictions.\\nExplore the data\\n Before you train your models, you need to develop understanding\\nof the data. Real-world data sets are often noisy, are missing\\nvalues, or have a host of other discrepancies. You can use data\\nsummarization and visualization to audit the quality of your data\\nbefore it's ready for modeling.\\nSet up a data pipeline\\n In addition to the initial ingestion and cleaning of the data, you \\ntypically need to set up a process to score new data or refresh the \\ndata regularly as part of an ongoing learning process. \\n3rd stage : Modeling\\n12\\nGoals\\n Determine the optimal data features for the \\nmachine-learning model.\\n Create an informative machine-learning model that \\npredicts the target most accurately.\\n Create a machine-learning model that's suitable for \\nproduction.\\n3rd stage : Modeling\\n13\\nThere are three main tasks addressed in this stage:\\n1.\\nFeature engineering\\n2.\\nModel training\\n3.\\nEvaluate\\n3rd stage : Modeling\\n14\\nThere are three main tasks addressed in this stage:\\n Feature engineering: Create data features from the raw \\ndata to facilitate model training.\\n Feature engineering is a balancing act of finding and \\nincluding informative variables, but at the same time trying \\nto avoid too many unrelated variables.\\n Informative variables improve your result; unrelated \\nvariables introduce unnecessary noise into the model. You \\nalso need to generate these features for any new data \\nobtained during scoring. As a result, the generation of these \\nfeatures can only depend on data that's available at the \\ntime of scoring.\\n3rd stage : Modeling\\n15\\nThere are three main tasks addressed in this stage:\\n Model training: Find the model that answers the question most \\naccurately by comparing their success metrics. Depending on the \\ntype of question that you're trying to answer, there are many \\nmodeling algorithms available. \\n Split the input data randomly for modeling into a training data set and \\na test data set.\\n Build the models by using the training data set.\\n Evaluate the training and the test data set. Use a series of competing \\nmachine-learning algorithms along with the various associated tuning \\nparameters (known as a parameter sweep) that are geared toward \\nanswering the question of interest with the current data.\\n Determine the \\\"best\\\" solution to answer the question by comparing the \\nsuccess metrics between alternative methods.\\n3rd stage : Modeling\\n16\\nThere are three main tasks addressed in this stage:\\n Model Evaluation: After training, the data scientist \\nfocuses next on model evaluation.\\nEvaluate whether the model performs sufficiently for \\nproduction. Some key questions to ask are:\\n Does the model answer the question with sufficient \\nconfidence given the test data?\\n Should you try any alternative approaches?\\n Should you collect additional data, do more feature \\nengineering, or experiment with other algorithms?\\n4th stage : Deployment\\n17\\nGoal\\n Deploy models with a data pipeline to a production \\nor production-like environment for final user \\nacceptance.\\n4th stage : Deployment\\n18\\nHow to do it\\nThe main task addressed in this stage:\\n Operationalize the model:\\n After you have a set of models that perform well, you can operationalize \\nthem for other applications to consume. Depending on the business \\nrequirements, predictions are made either in real time or on a batch basis. \\nTo deploy models, you representation them with an open API interface. \\nThe interface enables the model to be easily consumed from various \\napplications, such as:\\n Online websites\\n Spreadsheets\\n Dashboards\\n Line-of-business applications\\n Back-end applications\\n5th stage : Customer acceptance\\n19\\nGoal\\n Finalize project deliverables: Confirm that the \\npipeline, the model, and their deployment in a \\nproduction environment satisfy the customer's \\nobjectives.\\n5th stage : Customer acceptance\\n20\\n How to do it\\nThere are two main tasks addressed in this stage:\\n System validation: Confirm that the deployed model and pipeline \\nmeet the customer's needs.\\n Project hand-off: Hand the project off to the entity that's going to \\nrun the system in production.\\n The customer should validate that the system meets their business needs \\nand that it answers the questions with acceptable accuracy to deploy the \\nsystem to production for use by their client's application. All the \\ndocumentation is finalized and reviewed. The project is handed-off to \\nthe entity responsible for operations. This entity might be, for example, \\nan IT or customer data-science team or an agent of the customer that's \\nresponsible for running the system in production.\\nResources: Azure\\n21\\n Team Data Science Process : https://learn.microsoft.com/en-\\nus/azure/architecture/data-science-process/group-manager-tasks\\nGenerate a medium short answer question with its answer",
        "output: {\n  \"questions\": [\n    {\n      \"question\": \"What are the main goals of the Modeling stage in the data science lifecycle?\",\n      \"options\": [\n        \"A) Develop data visualization techniques\",\n        \"B) Implement data pipelines for data acquisition\",\n        \"C) Determine optimal features for machine-learning models\",\n        \"D) Define business objectives and data sources\"\n      ],\n      \"correct_answer\": \"C) Determine optimal features for machine-learning models\"\n    }\n  ]\n}",
        "input: DATA SCİENCE\\nFUNDAMENTALS\\nDr. Diaa Salama\\nLecture Slides for\\nData Science Process?\\n2\\n The methodology Life Cycle to deliver predictive\\nanalytics\\nsolutions\\nand\\nintelligent\\napplications\\nefficiently.\\n helps improve team collaboration and learning by\\nsuggesting how team roles work best together.\\n This Data Science project life cycle\\nand its main\\ncomponents by provide a generic description of the\\nprocess here that can be implemented with different\\nkinds of tools.\\n A more detailed description of the project tasks and\\nroles involved in the lifecycle of the process is provided.\\nData science lifecycle\\n3\\n provides a lifecycle to structure the development of \\nyour data science projects.\\n The lifecycle outlines the major stages that projects \\ntypically execute, often iteratively:\\n1. Business Understanding\\n2. Data Acquisition and Understanding\\n3. Modeling\\n4. Deployment\\nData science lifecycle\\n4\\n1st stage :The business understanding\\n5\\nGoal of The business understanding stage\\n Specify the key variables that are to serve as the \\nmodel targets \\n Identify the relevant data sources (needs to \\nobtain).\\n1st stage :The business understanding\\n6\\n (Objective) There are two main tasks addressed in this \\nstage:\\n Define objectives: Work with your customer and other\\nstakeholders to understand and identify the business\\nproblems.\\nFormulate\\nquestions\\nthat\\ndefine\\nthe\\nbusiness goals that the data science techniques can\\ntarget.\\n Identify data sources: Find the relevant data that \\nhelps you answer the questions that define the \\nobjectives of the project.\\nCont. 1st stage :The business \\nunderstanding (Define objectives)\\n7\\n Define the project goals by asking and refining \\\"sharp\\\" questions\\nthat are relevant, specific, and unambiguous. Data science is a\\nprocess that uses names and numbers to answer such questions. You\\ntypically use data science or machine learning to answer five\\ntypes of questions:\\n1.\\nHow much or how many? (regression)\\n2.\\nWhich category? (classification)\\n3.\\nWhich group? (clustering)\\n4.\\nIs this weird? (anomaly detection)\\n5.\\nWhich option should be taken? (recommendation)\\nDetermine which of these questions you're asking and how answering it\\nachieves your business goals.\\nCont. 1st stage :The business \\nunderstanding (Identify data sources)\\n8\\n Identify\\ndata\\nsources\\nthat\\ncontain\\nknown\\nexamples of answers to your sharp questions.\\n Data that's relevant to the question. \\n you might find that the existing systems need and achieve\\nthe project goals. In this situation, you might want to look\\nfor external data sources or update your systems to\\ncollect new data to collect and log additional kinds of\\ndata to address the problem\\n2nd stage :Data acquisition and understanding\\n9\\nGoals\\n Locate the data set in the fitting analytics \\nenvironment so you are ready to model.\\n Produce a clean, high-quality data set whose \\nrelationship to the target variables is understood.\\n Develop a solution architecture of the data \\npipeline that refreshes and scores the data \\nregularly.\\n2nd stage :Data acquisition and understanding\\n10\\nObjective There are three main tasks addressed in this\\nstage:\\n Ingest the data into the target analytic environment.\\n Explore the data to determine if the data quality is\\nacceptable to answer the question.\\n Set up a data pipeline to score new or regularly\\nrefreshed data.\\n2nd stage :Data acquisition and understanding\\n11\\nIngest the data\\n move the data from the source locations to the target locations\\nwhere you run analytics operations, like training and predictions.\\nExplore the data\\n Before you train your models, you need to develop understanding\\nof the data. Real-world data sets are often noisy, are missing\\nvalues, or have a host of other discrepancies. You can use data\\nsummarization and visualization to audit the quality of your data\\nbefore it's ready for modeling.\\nSet up a data pipeline\\n In addition to the initial ingestion and cleaning of the data, you \\ntypically need to set up a process to score new data or refresh the \\ndata regularly as part of an ongoing learning process. \\n3rd stage : Modeling\\n12\\nGoals\\n Determine the optimal data features for the \\nmachine-learning model.\\n Create an informative machine-learning model that \\npredicts the target most accurately.\\n Create a machine-learning model that's suitable for \\nproduction.\\n3rd stage : Modeling\\n13\\nThere are three main tasks addressed in this stage:\\n1.\\nFeature engineering\\n2.\\nModel training\\n3.\\nEvaluate\\n3rd stage : Modeling\\n14\\nThere are three main tasks addressed in this stage:\\n Feature engineering: Create data features from the raw \\ndata to facilitate model training.\\n Feature engineering is a balancing act of finding and \\nincluding informative variables, but at the same time trying \\nto avoid too many unrelated variables.\\n Informative variables improve your result; unrelated \\nvariables introduce unnecessary noise into the model. You \\nalso need to generate these features for any new data \\nobtained during scoring. As a result, the generation of these \\nfeatures can only depend on data that's available at the \\ntime of scoring.\\n3rd stage : Modeling\\n15\\nThere are three main tasks addressed in this stage:\\n Model training: Find the model that answers the question most \\naccurately by comparing their success metrics. Depending on the \\ntype of question that you're trying to answer, there are many \\nmodeling algorithms available. \\n Split the input data randomly for modeling into a training data set and \\na test data set.\\n Build the models by using the training data set.\\n Evaluate the training and the test data set. Use a series of competing \\nmachine-learning algorithms along with the various associated tuning \\nparameters (known as a parameter sweep) that are geared toward \\nanswering the question of interest with the current data.\\n Determine the \\\"best\\\" solution to answer the question by comparing the \\nsuccess metrics between alternative methods.\\n3rd stage : Modeling\\n16\\nThere are three main tasks addressed in this stage:\\n Model Evaluation: After training, the data scientist \\nfocuses next on model evaluation.\\nEvaluate whether the model performs sufficiently for \\nproduction. Some key questions to ask are:\\n Does the model answer the question with sufficient \\nconfidence given the test data?\\n Should you try any alternative approaches?\\n Should you collect additional data, do more feature \\nengineering, or experiment with other algorithms?\\n4th stage : Deployment\\n17\\nGoal\\n Deploy models with a data pipeline to a production \\nor production-like environment for final user \\nacceptance.\\n4th stage : Deployment\\n18\\nHow to do it\\nThe main task addressed in this stage:\\n Operationalize the model:\\n After you have a set of models that perform well, you can operationalize \\nthem for other applications to consume. Depending on the business \\nrequirements, predictions are made either in real time or on a batch basis. \\nTo deploy models, you representation them with an open API interface. \\nThe interface enables the model to be easily consumed from various \\napplications, such as:\\n Online websites\\n Spreadsheets\\n Dashboards\\n Line-of-business applications\\n Back-end applications\\n5th stage : Customer acceptance\\n19\\nGoal\\n Finalize project deliverables: Confirm that the \\npipeline, the model, and their deployment in a \\nproduction environment satisfy the customer's \\nobjectives.\\n5th stage : Customer acceptance\\n20\\n How to do it\\nThere are two main tasks addressed in this stage:\\n System validation: Confirm that the deployed model and pipeline \\nmeet the customer's needs.\\n Project hand-off: Hand the project off to the entity that's going to \\nrun the system in production.\\n The customer should validate that the system meets their business needs \\nand that it answers the questions with acceptable accuracy to deploy the \\nsystem to production for use by their client's application. All the \\ndocumentation is finalized and reviewed. The project is handed-off to \\nthe entity responsible for operations. This entity might be, for example, \\nan IT or customer data-science team or an agent of the customer that's \\nresponsible for running the system in production.\\nResources: Azure\\n21\\n Team Data Science Process : https://learn.microsoft.com/en-\\nus/azure/architecture/data-science-process/group-manager-tasks\\nGenerate a medium short answer question with its answer",
        "output: {\n  \"questions\": [\n    {\n      \"question\": \"What are the key objectives of the Modeling stage in the data science lifecycle?\",\n      \"answer\": \"The Modeling stage aims to optimize data features, train accurate machine-learning models, and evaluate model performance for effective deployment in real-world applications.\"\n    }\n  ]\n}",
        "input: input: DATA SCİENCE\\nFUNDAMENTALS\\nDr. Diaa Salama\\nLecture Slides for\\nData Science Process?\\n2\\n The methodology Life Cycle to deliver predictive\\nanalytics\\nsolutions\\nand\\nintelligent\\napplications\\nefficiently.\\n helps improve team collaboration and learning by\\nsuggesting how team roles work best together.\\n This Data Science project life cycle\\nand its main\\ncomponents by provide a generic description of the\\nprocess here that can be implemented with different\\nkinds of tools.\\n A more detailed description of the project tasks and\\nroles involved in the lifecycle of the process is provided.\\nData science lifecycle\\n3\\n provides a lifecycle to structure the development of \\nyour data science projects.\\n The lifecycle outlines the major stages that projects \\ntypically execute, often iteratively:\\n1. Business Understanding\\n2. Data Acquisition and Understanding\\n3. Modeling\\n4. Deployment\\nData science lifecycle\\n4\\n1st stage :The business understanding\\n5\\nGoal of The business understanding stage\\n Specify the key variables that are to serve as the \\nmodel targets \\n Identify the relevant data sources (needs to \\nobtain).\\n1st stage :The business understanding\\n6\\n (Objective) There are two main tasks addressed in this \\nstage:\\n Define objectives: Work with your customer and other\\nstakeholders to understand and identify the business\\nproblems.\\nFormulate\\nquestions\\nthat\\ndefine\\nthe\\nbusiness goals that the data science techniques can\\ntarget.\\n Identify data sources: Find the relevant data that \\nhelps you answer the questions that define the \\nobjectives of the project.\\nCont. 1st stage :The business \\nunderstanding (Define objectives)\\n7\\n Define the project goals by asking and refining \\\"sharp\\\" questions\\nthat are relevant, specific, and unambiguous. Data science is a\\nprocess that uses names and numbers to answer such questions. You\\ntypically use data science or machine learning to answer five\\ntypes of questions:\\n1.\\nHow much or how many? (regression)\\n2.\\nWhich category? (classification)\\n3.\\nWhich group? (clustering)\\n4.\\nIs this weird? (anomaly detection)\\n5.\\nWhich option should be taken? (recommendation)\\nDetermine which of these questions you're asking and how answering it\\nachieves your business goals.\\nCont. 1st stage :The business \\nunderstanding (Identify data sources)\\n8\\n Identify\\ndata\\nsources\\nthat\\ncontain\\nknown\\nexamples of answers to your sharp questions.\\n Data that's relevant to the question. \\n you might find that the existing systems need and achieve\\nthe project goals. In this situation, you might want to look\\nfor external data sources or update your systems to\\ncollect new data to collect and log additional kinds of\\ndata to address the problem\\n2nd stage :Data acquisition and understanding\\n9\\nGoals\\n Locate the data set in the fitting analytics \\nenvironment so you are ready to model.\\n Produce a clean, high-quality data set whose \\nrelationship to the target variables is understood.\\n Develop a solution architecture of the data \\npipeline that refreshes and scores the data \\nregularly.\\n2nd stage :Data acquisition and understanding\\n10\\nObjective There are three main tasks addressed in this\\nstage:\\n Ingest the data into the target analytic environment.\\n Explore the data to determine if the data quality is\\nacceptable to answer the question.\\n Set up a data pipeline to score new or regularly\\nrefreshed data.\\n2nd stage :Data acquisition and understanding\\n11\\nIngest the data\\n move the data from the source locations to the target locations\\nwhere you run analytics operations, like training and predictions.\\nExplore the data\\n Before you train your models, you need to develop understanding\\nof the data. Real-world data sets are often noisy, are missing\\nvalues, or have a host of other discrepancies. You can use data\\nsummarization and visualization to audit the quality of your data\\nbefore it's ready for modeling.\\nSet up a data pipeline\\n In addition to the initial ingestion and cleaning of the data, you \\ntypically need to set up a process to score new data or refresh the \\ndata regularly as part of an ongoing learning process. \\n3rd stage : Modeling\\n12\\nGoals\\n Determine the optimal data features for the \\nmachine-learning model.\\n Create an informative machine-learning model that \\npredicts the target most accurately.\\n Create a machine-learning model that's suitable for \\nproduction.\\n3rd stage : Modeling\\n13\\nThere are three main tasks addressed in this stage:\\n1.\\nFeature engineering\\n2.\\nModel training\\n3.\\nEvaluate\\n3rd stage : Modeling\\n14\\nThere are three main tasks addressed in this stage:\\n Feature engineering: Create data features from the raw \\ndata to facilitate model training.\\n Feature engineering is a balancing act of finding and \\nincluding informative variables, but at the same time trying \\nto avoid too many unrelated variables.\\n Informative variables improve your result; unrelated \\nvariables introduce unnecessary noise into the model. You \\nalso need to generate these features for any new data \\nobtained during scoring. As a result, the generation of these \\nfeatures can only depend on data that's available at the \\ntime of scoring.\\n3rd stage : Modeling\\n15\\nThere are three main tasks addressed in this stage:\\n Model training: Find the model that answers the question most \\naccurately by comparing their success metrics. Depending on the \\ntype of question that you're trying to answer, there are many \\nmodeling algorithms available. \\n Split the input data randomly for modeling into a training data set and \\na test data set.\\n Build the models by using the training data set.\\n Evaluate the training and the test data set. Use a series of competing \\nmachine-learning algorithms along with the various associated tuning \\nparameters (known as a parameter sweep) that are geared toward \\nanswering the question of interest with the current data.\\n Determine the \\\"best\\\" solution to answer the question by comparing the \\nsuccess metrics between alternative methods.\\n3rd stage : Modeling\\n16\\nThere are three main tasks addressed in this stage:\\n Model Evaluation: After training, the data scientist \\nfocuses next on model evaluation.\\nEvaluate whether the model performs sufficiently for \\nproduction. Some key questions to ask are:\\n Does the model answer the question with sufficient \\nconfidence given the test data?\\n Should you try any alternative approaches?\\n Should you collect additional data, do more feature \\nengineering, or experiment with other algorithms?\\n4th stage : Deployment\\n17\\nGoal\\n Deploy models with a data pipeline to a production \\nor production-like environment for final user \\nacceptance.\\n4th stage : Deployment\\n18\\nHow to do it\\nThe main task addressed in this stage:\\n Operationalize the model:\\n After you have a set of models that perform well, you can operationalize \\nthem for other applications to consume. Depending on the business \\nrequirements, predictions are made either in real time or on a batch basis. \\nTo deploy models, you representation them with an open API interface. \\nThe interface enables the model to be easily consumed from various \\napplications, such as:\\n Online websites\\n Spreadsheets\\n Dashboards\\n Line-of-business applications\\n Back-end applications\\n5th stage : Customer acceptance\\n19\\nGoal\\n Finalize project deliverables: Confirm that the \\npipeline, the model, and their deployment in a \\nproduction environment satisfy the customer's \\nobjectives.\\n5th stage : Customer acceptance\\n20\\n How to do it\\nThere are two main tasks addressed in this stage:\\n System validation: Confirm that the deployed model and pipeline \\nmeet the customer's needs.\\n Project hand-off: Hand the project off to the entity that's going to \\nrun the system in production.\\n The customer should validate that the system meets their business needs \\nand that it answers the questions with acceptable accuracy to deploy the \\nsystem to production for use by their client's application. All the \\ndocumentation is finalized and reviewed. The project is handed-off to \\nthe entity responsible for operations. This entity might be, for example, \\nan IT or customer data-science team or an agent of the customer that's \\nresponsible for running the system in production.\\nResources: Azure\\n21\\n Team Data Science Process : https://learn.microsoft.com/en-\\nus/azure/architecture/data-science-process/group-manager-tasks\\nGenerate hard short answer question with its answer",
        "output: {\n  \"questions\": [\n    {\n      \"question\": \"During the Data Acquisition and Understanding stage, what are the key tasks involved in ensuring data quality and preparing it for modeling?\",\n      \"answer\": \"Ingesting data into the target analytics environment, exploring the data to assess its quality, and establishing a data pipeline to score new or regularly refreshed data.\"\n    }\n  ]\n}",
        "input: " + input,
        "output: ",
    ]
    return prompt_parts
